Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package as needed\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.reflect.TypeToken;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.Airport;\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.AirportManager;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane.AirplaneStatus; // Import AirplaneStatus enum\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException;\r\nimport ucr.proyectoalgoritmos.Domain.list.DoublyLinkedList;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.Domain.stack.StackException;\r\nimport ucr.proyectoalgoritmos.route.RouteManager;\r\n\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Random;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class FlightSimulator {\r\n    private AirportManager airportManager;\r\n    private PassengerManager passengerManager;\r\n    private FlightScheduleManager flightScheduleManager;\r\n    private RouteManager routeManager;\r\n\r\n    private Map<String, Airplane> airplanes; // Stores all airplanes\r\n    private ScheduledExecutorService scheduler;\r\n    private Random random;\r\n\r\n    public FlightSimulator() throws ListException, IOException {\r\n        this.airportManager = new AirportManager();\r\n        this.routeManager = new RouteManager();\r\n        this.passengerManager = new PassengerManager();\r\n        this.flightScheduleManager = new FlightScheduleManager(this.airportManager, this.routeManager);\r\n\r\n        this.airplanes = new HashMap<>();\r\n        this.scheduler = Executors.newScheduledThreadPool(2); // Increased thread pool size for more concurrency\r\n        this.random = new Random();\r\n\r\n        // 1. System Initialization\r\n        initializeSystem();\r\n    }\r\n\r\n    private void initializeSystem() throws ListException, IOException {\r\n        System.out.println(\"--- System Initialization ---\");\r\n\r\n        // 1.1 Load Airports\r\n        loadAirportsFromFile(\"airports.json\");\r\n\r\n        // Add all loaded airports as vertices to the graph (no try-catch here, ListException propagates)\r\n        System.out.println(\"[INIT] Adding airports as graph vertices...\");\r\n        DoublyLinkedList allLoadedAirports = airportManager.getAllAirports();\r\n        if (allLoadedAirports != null && !allLoadedAirports.isEmpty()) {\r\n            for (int i = 0; i < allLoadedAirports.size(); i++) {\r\n                Airport airport = (Airport) allLoadedAirports.get(i);\r\n                routeManager.getGraph().addVertex(airport.getCode()); // Add each airport's code as a vertex\r\n            }\r\n            System.out.println(\"[INIT] All \" + routeManager.getGraph().getNumVertices() + \" airports added as graph vertices.\");\r\n        } else {\r\n            System.out.println(\"[WARN] No airports found in AirportManager to add as graph vertices.\");\r\n        }\r\n\r\n        // 1.2 Generate Random Routes (after airports are loaded AND added as graph vertices)\r\n        if (routeManager.getGraph().getNumVertices() < 2) {\r\n            System.err.println(\"[ERROR] Not enough airports (vertices) in the graph to generate routes. Please ensure at least 2 airports are loaded.\");\r\n        } else {\r\n            System.out.println(\"[INIT] Generating random routes between airports...\");\r\n            routeManager.getGraph().generateRandomRoutes(3, 7, 100, 3000);\r\n            System.out.println(\"[INIT] Random routes generated.\");\r\n        }\r\n\r\n        // Add some initial airplanes\r\n        addAirplane(\"AIR001\", 200, \"SJO\");\r\n        addAirplane(\"AIR002\", 150, \"MIA\");\r\n        addAirplane(\"AIR003\", 250, \"LIR\");\r\n        addAirplane(\"AIR004\", 100, \"LAX\");\r\n        addAirplane(\"AIR005\", 300, \"JFK\");\r\n        System.out.println(\"[INIT] Initial airplanes added.\");\r\n\r\n        // Add some initial passengers\r\n        passengerManager.registerPassenger(\"1001\", \"Alice Smith\", \"USA\");\r\n        passengerManager.registerPassenger(\"1002\", \"Bob Johnson\", \"Canada\");\r\n        passengerManager.registerPassenger(\"1003\", \"Carlos Garcia\", \"Mexico\");\r\n        passengerManager.registerPassenger(\"1004\", \"Diana Miller\", \"UK\");\r\n        passengerManager.registerPassenger(\"1005\", \"Eve Brown\", \"Germany\");\r\n        System.out.println(\"[INIT] Initial passengers registered.\");\r\n\r\n        System.out.println(\"--- System Initialization Complete ---\");\r\n    }\r\n\r\n    private void loadAirportsFromFile(String filename) throws ListException {\r\n        System.out.println(\"[INIT] Attempting to load airports from \" + filename + \"...\");\r\n        int loadedCount = 0;\r\n        try (Reader reader = Files.newBufferedReader(Paths.get(filename))) {\r\n            Gson gson = new Gson();\r\n            List<Airport> airportListFromFile = gson.fromJson(reader, new TypeToken<List<Airport>>() {\r\n            }.getType());\r\n\r\n            if (airportListFromFile != null) {\r\n                for (Airport airport : airportListFromFile) {\r\n                    if (loadedCount >= 20) {\r\n                        System.out.println(\"[INIT] Reached max 20 airports from file. Stopping.\");\r\n                        break;\r\n                    }\r\n                    airportManager.createAirport(airport.getCode(), airport.getName(), airport.getCountry());\r\n                    loadedCount++;\r\n                }\r\n            }\r\n\r\n            if (loadedCount < 15) {\r\n                System.out.println(\"[WARN] Only \" + loadedCount + \" airports loaded from file. Minimum 15 suggested.\");\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            System.err.println(\"[ERROR] Could not read airports file '\" + filename + \"': \" + e.getMessage());\r\n            System.out.println(\"[INFO] Generating some default airports instead.\");\r\n            addDefaultAirports();\r\n        } finally {\r\n            if (airportManager.getAllAirports().isEmpty()) {\r\n                System.out.println(\"[INFO] No airports loaded/created, adding emergency default airports.\");\r\n                addDefaultAirports();\r\n            }\r\n            System.out.println(\"[INIT] Total airports loaded/created: \" + airportManager.getAllAirports().size() + \".\");\r\n        }\r\n    }\r\n\r\n    private void addDefaultAirports() throws ListException {\r\n        if (airportManager.findAirport(\"SJO\") == null)\r\n            airportManager.createAirport(\"SJO\", \"Juan Santamaría\", \"Costa Rica\");\r\n        if (airportManager.findAirport(\"LIR\") == null)\r\n            airportManager.createAirport(\"LIR\", \"Daniel Oduber Quirós\", \"Costa Rica\");\r\n        if (airportManager.findAirport(\"MIA\") == null)\r\n            airportManager.createAirport(\"MIA\", \"Miami International\", \"USA\");\r\n        if (airportManager.findAirport(\"JFK\") == null)\r\n            airportManager.createAirport(\"JFK\", \"John F. Kennedy\", \"USA\");\r\n        if (airportManager.findAirport(\"LAX\") == null)\r\n            airportManager.createAirport(\"LAX\", \"Los Angeles International\", \"USA\");\r\n        if (airportManager.findAirport(\"CDG\") == null)\r\n            airportManager.createAirport(\"CDG\", \"Charles de Gaulle\", \"France\");\r\n        if (airportManager.findAirport(\"FRA\") == null)\r\n            airportManager.createAirport(\"FRA\", \"Frankfurt Airport\", \"Germany\");\r\n        if (airportManager.findAirport(\"DXB\") == null)\r\n            airportManager.createAirport(\"DXB\", \"Dubai International\", \"UAE\");\r\n        if (airportManager.findAirport(\"NRT\") == null)\r\n            airportManager.createAirport(\"NRT\", \"Narita International\", \"Japan\");\r\n        if (airportManager.findAirport(\"SYD\") == null)\r\n            airportManager.createAirport(\"SYD\", \"Sydney Airport\", \"Australia\");\r\n        if (airportManager.findAirport(\"ORD\") == null)\r\n            airportManager.createAirport(\"ORD\", \"O'Hare International\", \"USA\");\r\n        if (airportManager.findAirport(\"PEK\") == null)\r\n            airportManager.createAirport(\"PEK\", \"Beijing Capital\", \"China\");\r\n        if (airportManager.findAirport(\"IST\") == null)\r\n            airportManager.createAirport(\"IST\", \"Istanbul Airport\", \"Turkey\");\r\n        if (airportManager.findAirport(\"MEX\") == null)\r\n            airportManager.createAirport(\"MEX\", \"Mexico City Int'l\", \"Mexico\");\r\n        if (airportManager.findAirport(\"LIM\") == null)\r\n            airportManager.createAirport(\"LIM\", \"Jorge Chávez Int'l\", \"Peru\");\r\n    }\r\n\r\n    public void addAirplane(String id, int capacity, String initialLocationAirportCode) throws ListException {\r\n        if (airportManager.findAirport(initialLocationAirportCode) != null) {\r\n            if (!airplanes.containsKey(id)) {\r\n                airplanes.put(id, new Airplane(id, capacity, initialLocationAirportCode));\r\n                System.out.println(\"[INFO] Airplane '\" + id + \"' (Capacity: \" + capacity + \") created at \" + initialLocationAirportCode);\r\n            } else {\r\n                System.out.println(\"[WARN] Airplane \" + id + \" already exists. Skipping.\");\r\n            }\r\n        } else {\r\n            System.err.println(\"[ERROR] Cannot add airplane \" + id + \". Initial location \" + initialLocationAirportCode + \" is not a valid airport.\");\r\n        }\r\n    }\r\n\r\n    private void generateRandomFlightBasedOnRules() throws ListException, StackException {\r\n        System.out.println(\"\\n--- Generating new flight request ---\");\r\n\r\n        // Find the 5 airports with the most routes\r\n        DoublyLinkedList allAirportsList = airportManager.getAllAirports();\r\n        if (allAirportsList.isEmpty()) {\r\n            System.out.println(\"[WARN] No airports available to generate flights. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        List<Airport> activeAirports = new ArrayList<>();\r\n        for (int i = 0; i < allAirportsList.size(); i++) {\r\n            Airport airport = (Airport) allAirportsList.get(i);\r\n            if (airport.getStatus() == Airport.AirportStatus.ACTIVE) {\r\n                activeAirports.add(airport);\r\n            }\r\n        }\r\n\r\n        if (activeAirports.isEmpty()) {\r\n            System.out.println(\"[WARN] No active airports to generate flights. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        // Sort by outgoing route count (descending)\r\n        Collections.sort(activeAirports, new Comparator<Airport>() {\r\n            @Override\r\n            public int compare(Airport airport1, Airport airport2) {\r\n                int count1 = routeManager.getGraph().getOutgoingRouteCount(airport1.getCode());\r\n                int count2 = routeManager.getGraph().getOutgoingRouteCount(airport2.getCode());\r\n                return Integer.compare(count2, count1); // Descending order\r\n            }\r\n        });\r\n\r\n        List<Airport> selectedOrigins = new ArrayList<>();\r\n        for (int i = 0; i < Math.min(5, activeAirports.size()); i++) {\r\n            selectedOrigins.add(activeAirports.get(i));\r\n        }\r\n\r\n        if (selectedOrigins.isEmpty()) {\r\n            System.out.println(\"[WARN] Could not select suitable origin airports. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        // Pick a random origin from the selected top airports\r\n        Airport originAirport = selectedOrigins.get(random.nextInt(selectedOrigins.size()));\r\n        String originCode = originAirport.getCode();\r\n\r\n        // Find a random destination that is not the origin and has a route\r\n        List<String> allAirportCodes = routeManager.getGraph().getAllAirportCodes();\r\n        String destinationCode = null;\r\n        int attempts = 0;\r\n        final int MAX_ATTEMPTS = 50;\r\n\r\n        while (destinationCode == null || destinationCode.equals(originCode) ||\r\n                routeManager.calculateShortestRoute(originCode, destinationCode) == Integer.MAX_VALUE) {\r\n\r\n            if (allAirportCodes.isEmpty()) {\r\n                System.out.println(\"[WARN] No destination airports available. Cannot generate flight.\");\r\n                return;\r\n            }\r\n\r\n            if (attempts >= MAX_ATTEMPTS) {\r\n                System.out.println(\"[WARN] Failed to find a valid destination with a route from \" + originCode + \" after \" + MAX_ATTEMPTS + \" attempts. Cannot generate flight.\");\r\n                return;\r\n            }\r\n\r\n            destinationCode = allAirportCodes.get(random.nextInt(allAirportCodes.size()));\r\n            attempts++;\r\n        }\r\n\r\n        // --- MODIFIED LOGIC FOR AIRPLANE SELECTION AND FLIGHT SIMULATION ---\r\n        Airplane selectedAirplane = null;\r\n        for (Airplane airplane : airplanes.values()) {\r\n            if (airplane.getCurrentLocationAirportCode() != null && // Check if location is not null (e.g., in flight)\r\n                    airplane.getCurrentLocationAirportCode().equals(originCode) &&\r\n                    airplane.getStatus() == AirplaneStatus.IDLE) { // Ensure it's IDLE and at the origin\r\n                selectedAirplane = airplane;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (selectedAirplane == null) {\r\n            System.out.println(\"[WARN] No IDLE airplane available at \" + originCode + \" for flight to \" + destinationCode + \". Flight will be created but not simulated immediately.\");\r\n            // Create the flight schedule anyway, so it exists and passengers can be assigned\r\n            String flightNumber = \"FL\" + (random.nextInt(900) + 100);\r\n            LocalDateTime departureTime = LocalDateTime.now().plusHours(random.nextInt(12) + 1);\r\n            int capacity = 150 + random.nextInt(150); // Default capacity if no plane selected yet\r\n\r\n            flightScheduleManager.createFlight(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n\r\n            // Simulate passengers buying tickets for the created flight\r\n            int passengersBuyingTickets = random.nextInt(capacity / 2) + 1;\r\n            System.out.println(\"[INFO] Attempting to process tickets for \" + passengersBuyingTickets + \" passengers for flight \" + flightNumber);\r\n            for (int i = 0; i < passengersBuyingTickets; i++) {\r\n                String passengerId = \"100\" + (random.nextInt(5) + 1);\r\n                Passenger p = passengerManager.searchPassenger(passengerId);\r\n                if (p != null) {\r\n                    flightScheduleManager.processTicketPurchase(p, originCode, destinationCode);\r\n                } else {\r\n                    System.err.println(\"[ERROR] Passenger \" + passengerId + \" not found for ticket purchase simulation.\");\r\n                }\r\n            }\r\n            return; // Exit here, as we cannot simulate this flight without an available plane\r\n        }\r\n\r\n        // If an airplane is found and is IDLE, proceed with flight creation and simulation\r\n        int capacity = selectedAirplane.getCapacity(); // Use selected airplane's capacity\r\n        capacity = random.nextInt(capacity / 2) + capacity / 2; // Adjust capacity relative to selected plane\r\n        String flightNumber = \"FL\" + (random.nextInt(900) + 100);\r\n        LocalDateTime departureTime = LocalDateTime.now().plusHours(random.nextInt(12) + 1);\r\n\r\n        // Create the flight schedule\r\n        flightScheduleManager.createFlight(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n\r\n        // Simulate some passengers buying tickets\r\n        int passengersBuyingTickets = random.nextInt(capacity / 2) + 1;\r\n        System.out.println(\"[INFO] Attempting to process tickets for \" + passengersBuyingTickets + \" passengers for flight \" + flightNumber);\r\n        for (int i = 0; i < passengersBuyingTickets; i++) {\r\n            String passengerId = \"100\" + (random.nextInt(5) + 1);\r\n            Passenger p = passengerManager.searchPassenger(passengerId);\r\n            if (p != null) {\r\n                flightScheduleManager.processTicketPurchase(p, originCode, destinationCode);\r\n            } else {\r\n                System.err.println(\"[ERROR] Passenger \" + passengerId + \" not found for ticket purchase simulation.\");\r\n            }\r\n        }\r\n\r\n        // Now, trigger the flight simulation with the selected airplane\r\n        System.out.println(\"[SIM] Initiating simulation for flight \" + flightNumber + \" with airplane \" + selectedAirplane.getId() + \" from \" + originCode + \" to \" + destinationCode);\r\n        flightScheduleManager.simulateFlight(flightNumber, airportManager, passengerManager, selectedAirplane);\r\n    }\r\n\r\n    public void startSimulation(long flightGenerationIntervalSeconds, long simulationDurationSeconds) {\r\n        System.out.println(\"\\n--- Starting Flight Simulation ---\");\r\n        System.out.println(\"Flights will be generated every \" + flightGenerationIntervalSeconds + \" seconds.\");\r\n        System.out.println(\"Simulation will run for \" + simulationDurationSeconds + \" seconds.\");\r\n\r\n        scheduler.scheduleAtFixedRate(() -> {\r\n            try {\r\n                generateRandomFlightBasedOnRules();\r\n            } catch (ListException | StackException e) {\r\n                System.err.println(\"[RUNTIME ERROR] Error generating random flight: \" + e.getMessage());\r\n                // For a scheduled task, you might want more sophisticated error handling\r\n                // For now, it will just log and continue trying on the next interval\r\n            }\r\n        }, 1, flightGenerationIntervalSeconds, TimeUnit.SECONDS);\r\n\r\n        scheduler.schedule(() -> {\r\n            try {\r\n                stopSimulation();\r\n            } catch (ListException e) {\r\n                System.err.println(\"[RUNTIME ERROR] Error during simulation shutdown: \" + e.getMessage());\r\n            }\r\n        }, simulationDurationSeconds, TimeUnit.SECONDS);\r\n    }\r\n\r\n    public void stopSimulation() throws ListException {\r\n        System.out.println(\"\\n--- Stopping Flight Simulation ---\");\r\n        scheduler.shutdown();\r\n        try {\r\n            if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) { // Give tasks 10 seconds to finish\r\n                scheduler.shutdownNow();\r\n                System.out.println(\"[WARN] Forced shutdown of scheduler. Some tasks might not have completed.\");\r\n            }\r\n        } catch (InterruptedException e) {\r\n            scheduler.shutdownNow();\r\n            Thread.currentThread().interrupt();\r\n            System.err.println(\"[ERROR] Simulation shutdown was interrupted.\");\r\n            throw new RuntimeException(\"Simulation shutdown interrupted\", e);\r\n        }\r\n        System.out.println(\"\\n--- Flight Simulation Stopped ---\");\r\n\r\n        System.out.println(\"\\n--- Airplane Flight Histories ---\");\r\n        if (airplanes.isEmpty()) {\r\n            System.out.println(\"No airplanes in the system.\");\r\n        } else {\r\n            airplanes.values().forEach(Airplane::printFlightHistory);\r\n        }\r\n        System.out.println(\"---------------------------------\");\r\n\r\n        System.out.println(\"\\n--- Passenger Flight Histories ---\");\r\n        if (passengerManager.getPassengerCount() == 0) {\r\n            System.out.println(\"No passengers registered or with flight history.\");\r\n        } else {\r\n            // Print histories for the initial passengers\r\n            passengerManager.showFlightHistory(\"1001\");\r\n            passengerManager.showFlightHistory(\"1002\");\r\n            passengerManager.showFlightHistory(\"1003\");\r\n            passengerManager.showFlightHistory(\"1004\");\r\n            passengerManager.showFlightHistory(\"1005\");\r\n        }\r\n        System.out.println(\"----------------------------------\");\r\n\r\n        System.out.println(\"\\n--- Final Airport Status ---\");\r\n        airportManager.listAirports(true, true); // Assuming listAirports shows active airports and queue sizes\r\n        System.out.println(\"\\n--- Final Flight Schedule ---\");\r\n        flightScheduleManager.listAllFlights();\r\n        System.out.println(\"-----------------------------\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            FlightSimulator simulator = new FlightSimulator();\r\n            simulator.startSimulation(10, 60); // Generate every 10s, run for 60s\r\n\r\n        } catch (ListException e) {\r\n            System.err.println(\"[FATAL ERROR] Failed to initialize Flight Simulator due to ListException: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            System.err.println(\"[FATAL ERROR] Failed to initialize Flight Simulator due to IOException (e.g., airports file issue): \" + e.getMessage());\r\n            e.printStackTrace();\r\n        } catch (RuntimeException e) {\r\n            System.err.println(\"[FATAL ERROR] An unexpected runtime error occurred during simulation: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java	(date 1749465854531)
@@ -9,8 +9,8 @@
 import ucr.proyectoalgoritmos.Domain.airplane.Airplane.AirplaneStatus; // Import AirplaneStatus enum
 import ucr.proyectoalgoritmos.Domain.list.ListException;
 import ucr.proyectoalgoritmos.Domain.list.DoublyLinkedList;
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.Domain.stack.StackException;
 import ucr.proyectoalgoritmos.route.RouteManager;
 
Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package\r\n\r\nimport ucr.proyectoalgoritmos.Domain.Circular.CircularDoublyLinkedList;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.Airport;\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.AirportManager;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane;\r\nimport ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList;\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException; // This is the primary ListException\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.Domain.stack.StackException;\r\nimport ucr.proyectoalgoritmos.route.RouteManager;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Random;\r\nimport java.util.concurrent.TimeUnit; // For Thread.sleep\r\n\r\npublic class FlightScheduleManager {\r\n    public CircularDoublyLinkedList scheduledFlights; // Stores Flight objects\r\n    private AirportManager airportManager; // Dependency to check airport validity\r\n    private RouteManager routeManager;   // Dependency to get route distances\r\n    private Random random;\r\n\r\n    // A simple waiting list structure: Map<\"Origin-Destination\", SinglyLinkedList<Passenger>>\r\n    private Map<String, SinglyLinkedList> passengerWaitingLists;\r\n\r\n    public FlightScheduleManager(AirportManager airportManager, RouteManager routeManager) {\r\n        this.scheduledFlights = new CircularDoublyLinkedList();\r\n        this.airportManager = airportManager;\r\n        this.routeManager = routeManager;\r\n        this.random = new Random();\r\n        this.passengerWaitingLists = new HashMap<>();\r\n    }\r\n\r\n    // a. Create flight from an origin airport to a destination\r\n    public void createFlight(String flightNumber, String originCode, String destinationCode,\r\n                             LocalDateTime departureTime, int capacity) throws ListException {\r\n\r\n        // Business Rule: No flights to the same airport.\r\n        if (originCode.equalsIgnoreCase(destinationCode)) {\r\n            throw new ListException(\"Cannot create flight from \" + originCode + \" to \" + destinationCode + \": Origin and destination cannot be the same.\");\r\n        }\r\n\r\n        // Basic validation\r\n        if (airportManager.findAirport(originCode) == null) {\r\n            throw new ListException(\"Origin airport \" + originCode + \" does not exist.\");\r\n        }\r\n        if (airportManager.findAirport(destinationCode) == null) {\r\n            throw new ListException(\"Destination airport \" + destinationCode + \" does not exist.\");\r\n        }\r\n        // Check if flight number already exists\r\n        if (findFlight(flightNumber) != null) {\r\n            throw new ListException(\"Flight number \" + flightNumber + \" already exists.\");\r\n        }\r\n\r\n        FlightSchedule newFlight = new FlightSchedule(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n        scheduledFlights.add(newFlight); // Add to the Circular Doubly Linked List\r\n        System.out.println(\"[INFO] Flight created: \" + newFlight.getFlightNumber() + \" from \" + originCode + \" to \" + destinationCode);\r\n    }\r\n\r\n    // 3. Ticket Purchase - Assign passengers to flight\r\n    public void processTicketPurchase(Passenger passenger, String originCode, String destinationCode) throws ListException {\r\n        if (originCode.equalsIgnoreCase(destinationCode)) {\r\n            System.out.println(\"[TICKET] \" + passenger.getId() + \": Cannot book flight to same airport.\");\r\n            return;\r\n        }\r\n\r\n        // Find available flight with capacity\r\n        FlightSchedule availableFlight = null;\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getOriginAirportCode().equalsIgnoreCase(originCode) &&\r\n                    flight.getDestinationAirportCode().equalsIgnoreCase(destinationCode) &&\r\n                    flight.getStatus() == FlightSchedule.FlightStatus.SCHEDULED &&\r\n                    flight.getAvailableSeats() > 0) {\r\n                availableFlight = flight;\r\n                break; // Found one, take the first available\r\n            }\r\n        }\r\n\r\n        if (availableFlight != null) {\r\n            // Assign passenger to the flight\r\n            if (availableFlight.assignPassenger(passenger)) {\r\n                System.out.println(\"[TICKET] Passenger \" + passenger.getId() + \" assigned to flight \" + availableFlight.getFlightNumber());\r\n            } else {\r\n                System.out.println(\"[TICKET] Error assigning passenger \" + passenger.getId() + \" to flight \" + availableFlight.getFlightNumber() + \" (unexpectedly full).\");\r\n            }\r\n        } else {\r\n            // If no capacity, add to waiting list\r\n            System.out.println(\"[TICKET] No direct flight from \" + originCode + \" to \" + destinationCode + \" with available seats. Passenger \" + passenger.getId() + \" added to waiting list.\");\r\n            String routeKey = originCode + \"-\" + destinationCode;\r\n            // Get the list, or create it if it doesn't exist\r\n            SinglyLinkedList waitingList = passengerWaitingLists.computeIfAbsent(routeKey, k -> new SinglyLinkedList());\r\n            waitingList.add(passenger);\r\n        }\r\n    }\r\n\r\n    // Method to check waiting lists and assign passengers to new flights\r\n    public void assignWaitingPassengersToNewFlights(String originCode, String destinationCode) throws ListException {\r\n        String routeKey = originCode + \"-\" + destinationCode;\r\n        SinglyLinkedList waitingList = passengerWaitingLists.get(routeKey);\r\n\r\n        if (waitingList == null || waitingList.isEmpty()) {\r\n            return; // No waiting passengers for this route\r\n        }\r\n\r\n        // Find a suitable flight that is SCHEDULED and has capacity\r\n        FlightSchedule targetFlight = null;\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getOriginAirportCode().equalsIgnoreCase(originCode) &&\r\n                    flight.getDestinationAirportCode().equalsIgnoreCase(destinationCode) &&\r\n                    flight.getStatus() == FlightSchedule.FlightStatus.SCHEDULED &&\r\n                    flight.getAvailableSeats() > 0) {\r\n                targetFlight = flight;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (targetFlight != null) {\r\n            System.out.println(\"[WAITLIST] Attempting to assign waiting passengers for \" + routeKey + \" to flight \" + targetFlight.getFlightNumber());\r\n            int assignedCount = 0;\r\n            while (!waitingList.isEmpty() && targetFlight.getAvailableSeats() > 0) {\r\n                Passenger waitingPassenger = (Passenger) waitingList.getFirst(); // Get first in queue\r\n                if (targetFlight.assignPassenger(waitingPassenger)) {\r\n                    waitingList.removeFirst(); // Remove from waiting list if assigned\r\n                    assignedCount++;\r\n                } else {\r\n                    System.out.println(\"[WAITLIST] Flight became full unexpectedly during assignment for \" + waitingPassenger.getId());\r\n                    break;\r\n                }\r\n            }\r\n            System.out.println(\"[WAITLIST] \" + assignedCount + \" passengers assigned from waiting list for \" + routeKey + \". Remaining: \" + waitingList.size());\r\n        }\r\n    }\r\n\r\n    // c. Show active and completed flights\r\n    public void listFlights(FlightSchedule.FlightStatus statusFilter) throws ListException {\r\n        if (scheduledFlights.isEmpty()) {\r\n            System.out.println(\"No flights to list.\");\r\n            return;\r\n        }\r\n        System.out.println(\"\\n--- \" + (statusFilter != null ? statusFilter.name() : \"All\") + \" Flights ---\");\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (statusFilter == null || flight.getStatus() == statusFilter) {\r\n                System.out.println(flight);\r\n            }\r\n        }\r\n\r\n        System.out.println(\"--------------------------------\");\r\n    }\r\n\r\n    public void listAllFlights() throws ListException {\r\n        listFlights(null); // Show all flights\r\n    }\r\n\r\n    // d. Simulate flight (with route and passenger boarding)\r\n    // This method now also handles updating passenger history\r\n    public void simulateFlight(String flightNumber, AirportManager airportManager, PassengerManager passengerManager, Airplane airplane) throws ListException, StackException {\r\n        FlightSchedule flight = findFlight(flightNumber);\r\n        if (flight == null) {\r\n            throw new ListException(\"Flight \" + flightNumber + \" not found for simulation.\");\r\n        }\r\n\r\n        if (flight.getStatus() != FlightSchedule.FlightStatus.SCHEDULED) {\r\n            System.out.println(\"[SIM] Flight \" + flightNumber + \" is not in SCHEDULED status. Cannot simulate.\");\r\n            return;\r\n        }\r\n\r\n        // --- 4. Flight Simulation: Execute Dijkstra to find the shortest route ---\r\n        int routeDuration = routeManager.calculateShortestRoute(\r\n                flight.getOriginAirportCode(),\r\n                flight.getDestinationAirportCode());\r\n\r\n        if (routeDuration == Integer.MAX_VALUE) {\r\n            flight.setStatus(FlightSchedule.FlightStatus.CANCELLED); // Mark as cancelled if unreachable\r\n            throw new ListException(\"No route found from \" + flight.getOriginAirportCode() + \" to \" + flight.getDestinationAirportCode() + \". Flight \" + flightNumber + \" cancelled.\");\r\n        }\r\n\r\n        System.out.println(\"\\n--- Simulating Flight \" + flightNumber + \" ---\");\r\n        System.out.println(\"From: \" + flight.getOriginAirportCode() + \" (\" + airportManager.findAirport(flight.getOriginAirportCode()).getName() + \")\");\r\n        System.out.println(\"To: \" + flight.getDestinationAirportCode() + \" (\" + airportManager.findAirport(flight.getDestinationAirportCode()).getName() + \")\");\r\n        System.out.println(\"Occupancy: \" + flight.getOccupancy() + \"/\" + flight.getCapacity());\r\n        System.out.println(\"Estimated flight duration: \" + routeDuration + \" minutes\");\r\n\r\n        // Update airport departures board (optional, but good for realism)\r\n        Airport originAirport = airportManager.findAirport(flight.getOriginAirportCode());\r\n        if (originAirport != null) {\r\n            originAirport.removeFlightFromBoard(flight); // Assuming this method exists\r\n        }\r\n\r\n        airplane.boardPassengers(flight.getOccupancy()); // Transfer assigned passengers from Flight object to Airplane object\r\n\r\n        flight.setStatus(FlightSchedule.FlightStatus.ACTIVE);\r\n        airplane.takeOff(); // Airplane takes off\r\n\r\n        // --- Console Animation Logic ---\r\n        System.out.println(\"\\n-----------------------------------------------------\");\r\n        System.out.println(\"FLIGHT IN PROGRESS: \" + flight.getFlightNumber());\r\n        System.out.print(flight.getOriginAirportCode() + \" \");\r\n\r\n        int animationSteps = 30;\r\n        long totalAnimationTimeMs = routeDuration * 10L; // Simulate 10ms per minute of flight\r\n        long sleepTimePerStep = totalAnimationTimeMs / animationSteps;\r\n        if (sleepTimePerStep == 0) sleepTimePerStep = 1;\r\n\r\n        for (int i = 0; i < animationSteps; i++) {\r\n            try {\r\n                System.out.print(\">\");\r\n                if (i == animationSteps / 2) {\r\n                    System.out.print(\"✈\uFE0F\");\r\n                }\r\n                TimeUnit.MILLISECONDS.sleep(sleepTimePerStep);\r\n            } catch (InterruptedException e) {\r\n                Thread.currentThread().interrupt();\r\n                System.err.println(\"[SIM] Flight animation interrupted for \" + flightNumber + \".\");\r\n                flight.setStatus(FlightSchedule.FlightStatus.CANCELLED);\r\n                System.out.println(\"\\n-----------------------------------------------------\");\r\n                return;\r\n            }\r\n        }\r\n        System.out.println(\" \" + flight.getDestinationAirportCode());\r\n        System.out.println(\"-----------------------------------------------------\\n\");\r\n        // --- END Console Animation Logic ---\r\n\r\n        // --- 4. Flight Simulation: Upon arrival, empty the airplane's stack and restart the process. ---\r\n        flight.setStatus(FlightSchedule.FlightStatus.COMPLETED);\r\n        System.out.println(\"[SIM] Flight \" + flightNumber + \" has landed at \" + flight.getDestinationAirportCode() + \"!\");\r\n\r\n        // Create the history Flight object for the airplane and passengers\r\n        FlightHistory historyFlight =\r\n                new FlightHistory(\r\n                        flight.getOriginAirportCode(), flight.getDestinationAirportCode(),\r\n                        flight.getOccupancy(), flight.getDepartureTime(), LocalDateTime.now(), // Arrival time is now\r\n                        airplane.getId());\r\n\r\n        // Update each passenger's flight history *before* emptying the flight's assigned passenger list\r\n        SinglyLinkedList passengersOnThisFlight = flight.getAssignedPassengers();\r\n        for (int i = 0; i < passengersOnThisFlight.size(); i++) {\r\n            Passenger p = (Passenger) passengersOnThisFlight.get(i);\r\n            passengerManager.addFlightToPassengerHistory(p.getId(), historyFlight);\r\n        }\r\n\r\n        flight.emptyPassengers(); // Clears assignedPassengers list on the current Flight object\r\n        airplane.land(flight.getDestinationAirportCode(), historyFlight); // Empties airplane's passenger count, adds flight to airplane's history\r\n\r\n        // Assign waiting passengers to potentially new future flights (if you have them)\r\n        assignWaitingPassengersToNewFlights(flight.getOriginAirportCode(), flight.getDestinationAirportCode());\r\n    }\r\n\r\n    // Helper method to find a flight by number\r\n    public FlightSchedule findFlight(String flightNumber) throws ListException {\r\n        if (scheduledFlights.isEmpty()) {\r\n            return null;\r\n        }\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getFlightNumber().equalsIgnoreCase(flightNumber)) {\r\n                return flight;\r\n            }\r\n        }\r\n\r\n        return null; // Not found\r\n    }\r\n\r\n    public FlightHistory getFlightByIndex(int index) throws ListException {\r\n        if (index < 0 || index >= scheduledFlights.size()) {\r\n            throw new ListException(\"Flight index out of bounds: \" + index);\r\n        }\r\n        // This method should return FlightSchedule, not FlightHistory, if scheduledFlights holds FlightSchedule objects\r\n        return (FlightHistory) scheduledFlights.get(index); // Casting directly may cause ClassCastException\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java	(date 1749465854549)
@@ -7,8 +7,8 @@
 import ucr.proyectoalgoritmos.Domain.airplane.Airplane;
 import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList;
 import ucr.proyectoalgoritmos.Domain.list.ListException; // This is the primary ListException
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.Domain.stack.StackException;
 import ucr.proyectoalgoritmos.route.RouteManager;
 
Index: src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java
rename from src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java
rename to src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java	(date 1749465854634)
@@ -1,4 +1,4 @@
-package ucr.proyectoalgoritmos.Domain.passanger;
+package ucr.proyectoalgoritmos.Domain.passenger;
 
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistory;
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistoryList;
Index: src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java
rename from src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java
rename to src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java	(date 1749465854576)
@@ -1,4 +1,4 @@
-package ucr.proyectoalgoritmos.Domain.passanger;
+package ucr.proyectoalgoritmos.Domain.passenger;
 
 import ucr.proyectoalgoritmos.Domain.AVL; // Assuming your AVL is in Domain
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistory;
Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\nimport ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // For passengers assigned to this flight\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger; // For storing actual passengers\r\n\r\npublic class FlightSchedule implements Comparable<FlightSchedule> { // Implement Comparable for sorting/searching\r\n    private String flightNumber; // e.g., AA123\r\n    private String originAirportCode;\r\n    private String destinationAirportCode;\r\n    private LocalDateTime departureTime;\r\n    private int capacity;\r\n    private int occupancy; // Current number of passengers assigned/boarded\r\n    private FlightStatus status; // Enum for Scheduled, Active, Completed, Cancelled\r\n    private SinglyLinkedList assignedPassengers; // List of Passenger objects assigned to this flight\r\n\r\n    public FlightSchedule(String flightNumber, String originAirportCode, String destinationAirportCode,\r\n                          LocalDateTime departureTime, int capacity) {\r\n        this.flightNumber = flightNumber;\r\n        this.originAirportCode = originAirportCode;\r\n        this.destinationAirportCode = destinationAirportCode;\r\n        this.departureTime = departureTime;\r\n        this.capacity = capacity;\r\n        this.occupancy = 0; // Starts empty\r\n        this.status = FlightStatus.SCHEDULED; // Initial status\r\n        this.assignedPassengers = new SinglyLinkedList(); // Initialize list of passengers\r\n    }\r\n\r\n    // --- Getters ---\r\n    public String getFlightNumber() { return flightNumber; }\r\n    public String getOriginAirportCode() { return originAirportCode; }\r\n    public String getDestinationAirportCode() { return destinationAirportCode; }\r\n    public LocalDateTime getDepartureTime() { return departureTime; }\r\n    public int getCapacity() { return capacity; }\r\n    public int getOccupancy() { return occupancy; }\r\n    public FlightStatus getStatus() { return status; }\r\n    public int getAvailableSeats() { return capacity - occupancy; }\r\n    public SinglyLinkedList getAssignedPassengers() { return assignedPassengers; }\r\n\r\n    // --- Setters (for updatable attributes or status changes) ---\r\n    public void setDepartureTime(LocalDateTime departureTime) { this.departureTime = departureTime; }\r\n    public void setStatus(FlightStatus status) { this.status = status; }\r\n\r\n    // b. Assign passengers to the flight\r\n    public boolean assignPassenger(Passenger passenger) { // Assign one passenger\r\n        if (occupancy < capacity) {\r\n            this.assignedPassengers.add(passenger); // Add passenger object to list\r\n            occupancy++;\r\n            System.out.println(\"[FLIGHT \" + flightNumber + \"] Passenger \" + passenger.getId() + \" assigned. Occupancy: \" + occupancy);\r\n            return true;\r\n        } else {\r\n            System.out.println(\"[FLIGHT \" + flightNumber + \"] Cannot assign passenger \" + passenger.getId() + \". Flight is full.\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Empty passengers upon flight completion\r\n    public void emptyPassengers() {\r\n        this.occupancy = 0;\r\n        try {\r\n            this.assignedPassengers.clear(); // Clear the list of assigned passengers\r\n        } catch (Exception e) { /* should not happen for clear */ }\r\n        System.out.println(\"[FLIGHT \" + flightNumber + \"] Passengers emptied.\");\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\r\n        return \"Flight [Num: \" + flightNumber +\r\n                \", From: \" + originAirportCode +\r\n                \", To: \" + destinationAirportCode +\r\n                \", Depart: \" + departureTime.format(formatter) +\r\n                \", Cap: \" + capacity +\r\n                \", Occ: \" + occupancy +\r\n                \", Status: \" + status +\r\n                \"]\";\r\n    }\r\n\r\n    // For comparison in CircularDoublyLinkedList or other structures (e.g., by flight number)\r\n    @Override\r\n    public int compareTo(FlightSchedule other) {\r\n        return this.flightNumber.compareTo(other.flightNumber);\r\n    }\r\n\r\n    // Enum for flight status\r\n    public enum FlightStatus {\r\n        SCHEDULED,\r\n        ACTIVE,    // In transit\r\n        COMPLETED,\r\n        CANCELLED\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java	(date 1749465854563)
@@ -3,7 +3,7 @@
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // For passengers assigned to this flight
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger; // For storing actual passengers
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger; // For storing actual passengers
 
 public class FlightSchedule implements Comparable<FlightSchedule> { // Implement Comparable for sorting/searching
     private String flightNumber; // e.g., AA123
Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightController.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightController.java
new file mode 100644
--- /dev/null	(date 1749465992486)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightController.java	(date 1749465992486)
@@ -0,0 +1,153 @@
+package ucr.proyectoalgoritmos.Domain.flight;
+
+import ucr.proyectoalgoritmos.Domain.aeropuetos.Airport;
+import ucr.proyectoalgoritmos.Domain.Circular.CircularDoublyLinkedList;
+import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList;
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
+
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.time.temporal.ChronoUnit;
+import java.util.Random;
+
+/**
+ * Controlador para la gestión de vuelos que utiliza Circular Doubly Linked List
+ */
+public class FlightController {
+    private CircularDoublyLinkedList<FlightSchedule> activeFlights;
+    private CircularDoublyLinkedList<FlightSchedule> completedFlights;
+    private PassengerManager passengerManager;
+    private Random random;
+
+    public FlightController(PassengerManager passengerManager) {
+        this.activeFlights = new CircularDoublyLinkedList<>();
+        this.completedFlights = new CircularDoublyLinkedList<>();
+        this.passengerManager = passengerManager;
+        this.random = new Random();
+    }
+
+    /**
+     * Genera vuelos aleatorios entre aeropuertos
+     * @param numberOfFlights cantidad de vuelos a generar
+     * @param airports lista de aeropuertos disponibles
+     */
+    public void generateRandomFlights(int numberOfFlights, SinglyLinkedList<Airport> airports) {
+        if (airports == null || airports.isEmpty()) {
+            throw new IllegalArgumentException("La lista de aeropuertos no puede estar vacía");
+        }
+
+        for (int i = 0; i < numberOfFlights; i++) {
+            Airport origin = getRandomAirport(airports);
+            Airport destination;
+
+            // Asegurar que origen y destino no sean iguales
+            do {
+                destination = getRandomAirport(airports);
+            } while (destination.getCode().equals(origin.getCode()));
+
+            // Generar datos aleatorios para el vuelo
+            String flightNumber = generateFlightNumber(origin);
+            LocalDateTime departureTime = LocalDateTime.now()
+                    .plusHours(random.nextInt(72))
+                    .truncatedTo(ChronoUnit.MINUTES);
+
+            int capacity = getRandomCapacity();
+
+            FlightSchedule flight = new FlightSchedule(
+                    flightNumber,
+                    origin.getCode(),
+                    destination.getCode(),
+                    departureTime,
+                    capacity
+            );
+
+            activeFlights.add(flight);
+        }
+    }
+
+    /**
+     * Asigna pasajeros aleatorios a los vuelos disponibles
+     */
+    public void assignPassengersToFlights() {
+        for (FlightSchedule flight : activeFlights) {
+            if (flight.getStatus() == FlightSchedule.FlightStatus.SCHEDULED) {
+                int availableSeats = flight.getAvailableSeats();
+                int passengersToAssign = Math.min(availableSeats, random.nextInt(20) + 5);
+
+                for (int i = 0; i < passengersToAssign; i++) {
+                    Passenger passenger = passengerManager.getRandomPassenger();
+                    if (passenger != null) {
+                        flight.assignPassenger(passenger);
+                        passengerManager.addFlightToPassengerHistory(passenger.getId(), flight);
+                    }
+                }
+            }
+        }
+    }
+
+    private Airport getRandomAirport(SinglyLinkedList<Airport> airports) {
+        int index = random.nextInt(airports.size());
+        return airports.get(index);
+    }
+
+    private String generateFlightNumber(Airport origin) {
+        String airlineCode = origin.getCode().substring(0, 2).toUpperCase();
+        int flightNum = random.nextInt(900) + 100; // Números entre 100-999
+        return airlineCode + flightNum;
+    }
+
+    private int getRandomCapacity() {
+        int[] capacities = {100, 150, 200};
+        return capacities[random.nextInt(capacities.length)];
+    }
+
+    // Métodos para obtener los vuelos
+    public CircularDoublyLinkedList<FlightSchedule> getActiveFlights() {
+        return activeFlights;
+    }
+
+    public CircularDoublyLinkedList<FlightSchedule> getCompletedFlights() {
+        return completedFlights;
+    }
+
+    /**
+     * Valor agregado: simula el completado de un vuelo
+     */
+    public void completeFlight(String flightNumber) {
+        for (FlightSchedule flight : activeFlights) {
+            if (flight.getFlightNumber().equals(flightNumber)) {
+                flight.setStatus(FlightSchedule.FlightStatus.COMPLETED);
+                flight.emptyPassengers();
+                activeFlights.remove(flight);
+                completedFlights.add(flight);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Valor agregado: muestra reporte de ocupación
+     */
+    public String getOccupancyReport() {
+        StringBuilder report = new StringBuilder();
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
+
+        report.append("=== REPORTE DE OCUPACIÓN DE VUELOS ===\n");
+        for (FlightSchedule flight : activeFlights) {
+            double occupancyPercent = (flight.getOccupancy() * 100.0) / flight.getCapacity();
+            report.append(String.format(
+                    "Vuelo %s: %s -> %s | %s | Ocupación: %.1f%% (%d/%d)\n",
+                    flight.getFlightNumber(),
+                    flight.getOriginAirportCode(),
+                    flight.getDestinationAirportCode(),
+                    flight.getDepartureTime().format(formatter),
+                    occupancyPercent,
+                    flight.getOccupancy(),
+                    flight.getCapacity()
+            ));
+        }
+
+        return report.toString();
+    }
+}
\ No newline at end of file
Index: src/main/java/ucr/proyectoalgoritmos/util/Utility.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.util;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger; // Import your Passenger class\r\n\r\nimport java.text.DecimalFormat;\r\nimport java.util.Random;\r\n\r\npublic class Utility {\r\n\r\n    static {\r\n        // static initialization block, currently empty\r\n    }\r\n\r\n    public static String format(double value){\r\n        return new DecimalFormat(\"###,###,###.##\").format(value);\r\n    }\r\n    public static String $format(double value){\r\n        return new DecimalFormat(\"$###,###,###.##\").format(value);\r\n    }\r\n\r\n    public static void fill(int[] a, int bound) {\r\n        for (int i = 0; i < a.length; i++) {\r\n            a[i] = new Random().nextInt(bound);\r\n        }\r\n    }\r\n\r\n    public static int random(int bound) {\r\n        return new Random().nextInt(bound);\r\n    }\r\n\r\n    public static int compare(Object a, Object b) {\r\n        // Handle null cases explicitly for robustness\r\n        if (a == null && b == null) return 0;\r\n        if (a == null) return -1; // a is \"less\" than b if a is null\r\n        if (b == null) return 1;  // a is \"greater\" than b if b is null\r\n\r\n        switch (instanceOf(a, b)){\r\n            case \"Integer\":\r\n                Integer int1 = (Integer)a; Integer int2 = (Integer)b;\r\n                return int1 < int2 ? -1 : int1 > int2 ? 1 : 0; //0 == equal\r\n            case \"String\":\r\n                String st1 = (String)a; String st2 = (String)b;\r\n                return st1.compareTo(st2); // compareTo already returns -1, 0, or 1\r\n            case \"Character\":\r\n                Character c1 = (Character)a; Character c2 = (Character)b;\r\n                return c1.compareTo(c2); // compareTo already returns -1, 0, or 1\r\n            case \"Passenger\": // --- ADDED THIS CASE ---\r\n                Passenger p1 = (Passenger) a;\r\n                Passenger p2 = (Passenger) b;\r\n                return p1.getId().compareTo(p2.getId()); // Compare passengers by their ID\r\n            // case \"EdgeWeight\":\r\n            //    EdgeWeight ew1 = (EdgeWeight) a ; EdgeWeight ew2 = (EdgeWeight) b;\r\n            //    return compare(ew1.getEdge(), ew2.getEdge());\r\n        }\r\n        return 2; // Unknown type comparison - indicates a problem\r\n    }\r\n\r\n    private static String instanceOf(Object a, Object b) {\r\n        if(a instanceof Integer && b instanceof Integer) return \"Integer\";\r\n        if(a instanceof String && b instanceof String) return \"String\";\r\n        if(a instanceof Character && b instanceof Character) return \"Character\";\r\n        if (a instanceof Passenger && b instanceof Passenger) return \"Passenger\"; // --- ADDED THIS LINE ---\r\n        //if (a instanceof EdgeWeight && b instanceof EdgeWeight) return \"EdgeWeight\";\r\n        return \"Unknown\";\r\n    }\r\n\r\n    public static int maxArray(int[] a) {\r\n        int max = a[0]; //first element\r\n        for (int i = 1; i < a.length; i++) {\r\n            if(a[i]>max){\r\n                max=a[i];\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public static int[] getIntegerArray(int n) {\r\n        int[] newArray = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            newArray[i] = random(9999);\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n\r\n    public static int[] copyArray(int[] a) {\r\n        int n = a.length;\r\n        int[] newArray = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            newArray[i] = a[i];\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n    public static String show(int[] a, int n) {\r\n        String result=\"\";\r\n        for (int i = 0; i < n; i++) {\r\n            result+=a[i]+\" \";\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public static String RandomAlphabet() {\r\n        String[] Alphabet = {\r\n                \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\",\r\n                \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\r\n        };\r\n\r\n        Random random = new Random();\r\n        int randomIndex = random.nextInt(Alphabet.length);\r\n        return Alphabet[randomIndex];\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/util/Utility.java b/src/main/java/ucr/proyectoalgoritmos/util/Utility.java
--- a/src/main/java/ucr/proyectoalgoritmos/util/Utility.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/ucr/proyectoalgoritmos/util/Utility.java	(date 1749465854674)
@@ -1,6 +1,6 @@
 package ucr.proyectoalgoritmos.util;
 
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger; // Import your Passenger class
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger; // Import your Passenger class
 
 import java.text.DecimalFormat;
 import java.util.Random;
Index: src/main/java/module-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module ucr.proyectoalgoritmos {\r\n    requires javafx.controls;\r\n    requires javafx.fxml;\r\n    requires com.google.gson;\r\n\r\n    // Open packages for reflection (Gson needs access to private fields)\r\n    opens ucr.proyectoalgoritmos.Domain.aeropuetos to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.airplane to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.passanger to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.flight;\r\n    opens ucr.proyectoalgoritmos.Domain.list to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.queue to com.google.gson; // <--- ADD THIS NEW CRITICAL LINE!\r\n    opens ucr.proyectoalgoritmos.route to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.stack to com.google.gson;\r\n    // If your Node class is in a separate package (e.g., if Node is generic and used by multiple structures\r\n    // and its own package), you might need an opens for that package too.\r\n    // If your queue's Node is inside the Domain.queue package, the above line covers it.\r\n\r\n    // Open/Export packages for JavaFX and general access\r\n    opens ucr.proyectoalgoritmos to javafx.fxml;\r\n    exports ucr.proyectoalgoritmos;\r\n\r\n    exports ucr.proyectoalgoritmos.Controller;\r\n    opens ucr.proyectoalgoritmos.Controller to javafx.fxml;\r\n\r\n    // Export your domain packages if other modules might use them\r\n    exports ucr.proyectoalgoritmos.Domain.aeropuetos;\r\n    exports ucr.proyectoalgoritmos.Domain.airplane;\r\n    exports ucr.proyectoalgoritmos.Domain.flight;\r\n    exports ucr.proyectoalgoritmos.Domain.list;\r\n    exports ucr.proyectoalgoritmos.Domain.passanger; // Typo 'passanger' vs 'passenger' - check your actual package name!\r\n//    exports ucr.proyectoalgoritmos.Domain.passenger; // If you refactored it\r\n    exports ucr.proyectoalgoritmos.Domain.queue; // <--- Make sure this is exported too\r\n    exports ucr.proyectoalgoritmos.Domain.stack;\r\n    exports ucr.proyectoalgoritmos.route;\r\n    exports ucr.proyectoalgoritmos.util;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/module-info.java b/src/main/java/module-info.java
--- a/src/main/java/module-info.java	(revision b7324fc94269583f8b6e9e5ed3ecfdb7a4fa48ce)
+++ b/src/main/java/module-info.java	(date 1749465854597)
@@ -6,7 +6,7 @@
     // Open packages for reflection (Gson needs access to private fields)
     opens ucr.proyectoalgoritmos.Domain.aeropuetos to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.airplane to com.google.gson;
-    opens ucr.proyectoalgoritmos.Domain.passanger to com.google.gson;
+    opens ucr.proyectoalgoritmos.Domain.passenger to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.flight;
     opens ucr.proyectoalgoritmos.Domain.list to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.queue to com.google.gson; // <--- ADD THIS NEW CRITICAL LINE!
@@ -28,7 +28,7 @@
     exports ucr.proyectoalgoritmos.Domain.airplane;
     exports ucr.proyectoalgoritmos.Domain.flight;
     exports ucr.proyectoalgoritmos.Domain.list;
-    exports ucr.proyectoalgoritmos.Domain.passanger; // Typo 'passanger' vs 'passenger' - check your actual package name!
+    exports ucr.proyectoalgoritmos.Domain.passenger; // Typo 'passanger' vs 'passenger' - check your actual package name!
 //    exports ucr.proyectoalgoritmos.Domain.passenger; // If you refactored it
     exports ucr.proyectoalgoritmos.Domain.queue; // <--- Make sure this is exported too
     exports ucr.proyectoalgoritmos.Domain.stack;
