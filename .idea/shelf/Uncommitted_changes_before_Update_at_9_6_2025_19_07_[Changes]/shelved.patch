Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package as needed\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.reflect.TypeToken;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.Airport;\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.AirportManager;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane.AirplaneStatus; // Import AirplaneStatus enum\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException;\r\nimport ucr.proyectoalgoritmos.Domain.list.DoublyLinkedList;\r\nimport ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // Ensure this is imported for type consistency\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.Domain.stack.StackException;\r\nimport ucr.proyectoalgoritmos.route.RouteManager; // Import RouteManager\r\nimport ucr.proyectoalgoritmos.route.Route; // Import your Route class\r\n\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Random;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class FlightSimulator {\r\n    private AirportManager airportManager;\r\n    private PassengerManager passengerManager;\r\n    private FlightScheduleManager flightScheduleManager;\r\n    private RouteManager routeManager; // Make sure this is initialized correctly\r\n\r\n    private Map<String, Airplane> airplanes; // Stores all airplanes\r\n    private ScheduledExecutorService scheduler;\r\n    private Random random;\r\n\r\n    public FlightSimulator() throws ListException, IOException {\r\n        this.airportManager = new AirportManager();\r\n        // Pass AirportManager to RouteManager so it can resolve airport codes to indices\r\n        this.routeManager = new RouteManager(airportManager); // <--- IMPORTANT: Pass AirportManager\r\n        this.passengerManager = new PassengerManager();\r\n        // Pass the already initialized AirportManager and RouteManager\r\n        this.flightScheduleManager = new FlightScheduleManager(this.airportManager, this.routeManager);\r\n\r\n        this.airplanes = new HashMap<>();\r\n        this.scheduler = Executors.newScheduledThreadPool(2); // Increased thread pool size for more concurrency\r\n        this.random = new Random();\r\n\r\n        // 1. System Initialization\r\n        initializeSystem();\r\n    }\r\n\r\n    private void initializeSystem() throws ListException, IOException {\r\n        System.out.println(\"--- System Initialization ---\");\r\n\r\n        // 1.1 Load Airports\r\n        loadAirportsFromFile(\"airports.json\");\r\n\r\n        // Add all loaded airports as vertices to the graph (no try-catch here, ListException propagates)\r\n        System.out.println(\"[INIT] Adding airports as graph vertices...\");\r\n        DoublyLinkedList allLoadedAirports = airportManager.getAllAirports();\r\n        if (allLoadedAirports != null && !allLoadedAirports.isEmpty()) {\r\n            for (int i = 0; i < allLoadedAirports.size(); i++) {\r\n                Airport airport = (Airport) allLoadedAirports.get(i); // Explicit cast\r\n                routeManager.getGraph().addVertex(airport.getCode()); // Add each airport's code as a vertex\r\n            }\r\n            System.out.println(\"[INIT] All \" + routeManager.getGraph().getNumVertices() + \" airports added as graph vertices.\");\r\n        } else {\r\n            System.out.println(\"[WARN] No airports found in AirportManager to add as graph vertices.\");\r\n        }\r\n\r\n        // --- START NEW/MODIFIED CODE FOR ROUTE LOADING ---\r\n        // 1.2 Load Routes from routes.json (instead of generating random ones)\r\n        // Ensure that airports (vertices) are added to the graph BEFORE loading routes (edges).\r\n        if (routeManager.getGraph().getNumVertices() < 2) {\r\n            System.err.println(\"[ERROR] Not enough airports (vertices) in the graph to load routes. Please ensure at least 2 airports are loaded.\");\r\n        } else {\r\n            System.out.println(\"[INIT] Loading routes from 'routes.json'...\");\r\n            try {\r\n                // Call the new method in RouteManager to load routes\r\n                routeManager.loadRoutesFromJson(\"routes.json\");\r\n                System.out.println(\"[INIT] Routes loaded from 'routes.json'. Total routes: \" + routeManager.getGraph().getNumEdges());\r\n            } catch (IOException e) {\r\n                System.err.println(\"[ERROR] Failed to load routes from 'routes.json': \" + e.getMessage());\r\n                // Fallback: If routes.json fails, generate random routes as a last resort\r\n                System.out.println(\"[INFO] Generating random routes as a fallback due to file loading error.\");\r\n                routeManager.getGraph().generateRandomRoutes(3, 7, 100, 3000);\r\n            }\r\n        }\r\n        // --- END NEW/MODIFIED CODE FOR ROUTE LOADING ---\r\n\r\n\r\n        // Add some initial airplanes\r\n        addAirplane(\"AIR001\", 200, \"SJO\");\r\n        addAirplane(\"AIR002\", 150, \"MIA\");\r\n        addAirplane(\"AIR003\", 250, \"LIR\");\r\n        addAirplane(\"AIR004\", 100, \"LAX\");\r\n        addAirplane(\"AIR005\", 300, \"JFK\");\r\n        System.out.println(\"[INIT] Initial airplanes added.\");\r\n\r\n        // Add some initial passengers\r\n        passengerManager.registerPassenger(\"1001\", \"Alice Smith\", \"USA\");\r\n        passengerManager.registerPassenger(\"1002\", \"Bob Johnson\", \"Canada\");\r\n        passengerManager.registerPassenger(\"1003\", \"Carlos Garcia\", \"Mexico\");\r\n        passengerManager.registerPassenger(\"1004\", \"Diana Miller\", \"UK\");\r\n        passengerManager.registerPassenger(\"1005\", \"Eve Brown\", \"Germany\");\r\n        System.out.println(\"[INIT] Initial passengers registered.\");\r\n\r\n        System.out.println(\"--- System Initialization Complete ---\");\r\n    }\r\n\r\n    private void loadAirportsFromFile(String filename) throws ListException {\r\n        System.out.println(\"[INIT] Attempting to load airports from \" + filename + \"...\");\r\n        int loadedCount = 0;\r\n        try (Reader reader = Files.newBufferedReader(Paths.get(filename))) {\r\n            Gson gson = new Gson();\r\n            List<Airport> airportListFromFile = gson.fromJson(reader, new TypeToken<List<Airport>>() {\r\n            }.getType());\r\n\r\n            if (airportListFromFile != null) {\r\n                for (Airport airport : airportListFromFile) {\r\n                    if (loadedCount >= 20) { // Limit to 20 airports from file\r\n                        System.out.println(\"[INIT] Reached max 20 airports from file. Stopping.\");\r\n                        break;\r\n                    }\r\n                    airportManager.createAirport(airport.getCode(), airport.getName(), airport.getCountry());\r\n                    loadedCount++;\r\n                }\r\n            }\r\n\r\n            if (loadedCount < 15) {\r\n                System.out.println(\"[WARN] Only \" + loadedCount + \" airports loaded from file. Minimum 15 suggested for robust simulation.\");\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            System.err.println(\"[ERROR] Could not read airports file '\" + filename + \"': \" + e.getMessage());\r\n            System.out.println(\"[INFO] Generating some default airports instead.\");\r\n            addDefaultAirports(); // Fallback to default airports if file loading fails\r\n        } finally {\r\n            if (airportManager.getAllAirports().isEmpty()) { // Final check if no airports exist\r\n                System.out.println(\"[INFO] No airports loaded/created, adding emergency default airports.\");\r\n                addDefaultAirports();\r\n            }\r\n            System.out.println(\"[INIT] Total airports loaded/created: \" + airportManager.getAllAirports().size() + \".\");\r\n        }\r\n    }\r\n\r\n    private void addDefaultAirports() throws ListException {\r\n        // Only add if not already present, to avoid duplicates if called multiple times\r\n        if (airportManager.findAirport(\"SJO\") == null)\r\n            airportManager.createAirport(\"SJO\", \"Juan Santamaría\", \"Costa Rica\");\r\n        if (airportManager.findAirport(\"LIR\") == null)\r\n            airportManager.createAirport(\"LIR\", \"Daniel Oduber Quirós\", \"Costa Rica\");\r\n        if (airportManager.findAirport(\"MIA\") == null)\r\n            airportManager.createAirport(\"MIA\", \"Miami International\", \"USA\");\r\n        if (airportManager.findAirport(\"JFK\") == null)\r\n            airportManager.createAirport(\"JFK\", \"John F. Kennedy\", \"USA\");\r\n        if (airportManager.findAirport(\"LAX\") == null)\r\n            airportManager.createAirport(\"LAX\", \"Los Angeles International\", \"USA\");\r\n        if (airportManager.findAirport(\"CDG\") == null)\r\n            airportManager.createAirport(\"CDG\", \"Charles de Gaulle\", \"France\");\r\n        if (airportManager.findAirport(\"FRA\") == null)\r\n            airportManager.createAirport(\"FRA\", \"Frankfurt Airport\", \"Germany\");\r\n        if (airportManager.findAirport(\"DXB\") == null)\r\n            airportManager.createAirport(\"DXB\", \"Dubai International\", \"UAE\");\r\n        if (airportManager.findAirport(\"NRT\") == null)\r\n            airportManager.createAirport(\"NRT\", \"Narita International\", \"Japan\");\r\n        if (airportManager.findAirport(\"SYD\") == null)\r\n            airportManager.createAirport(\"SYD\", \"Sydney Airport\", \"Australia\");\r\n        if (airportManager.findAirport(\"ORD\") == null)\r\n            airportManager.createAirport(\"ORD\", \"O'Hare International\", \"USA\");\r\n        if (airportManager.findAirport(\"PEK\") == null)\r\n            airportManager.createAirport(\"PEK\", \"Beijing Capital\", \"China\");\r\n        if (airportManager.findAirport(\"IST\") == null)\r\n            airportManager.createAirport(\"IST\", \"Istanbul Airport\", \"Turkey\");\r\n        if (airportManager.findAirport(\"MEX\") == null)\r\n            airportManager.createAirport(\"MEX\", \"Mexico City Int'l\", \"Mexico\");\r\n        if (airportManager.findAirport(\"LIM\") == null)\r\n            airportManager.createAirport(\"LIM\", \"Jorge Chávez Int'l\", \"Peru\");\r\n    }\r\n\r\n    public void addAirplane(String id, int capacity, String initialLocationAirportCode) throws ListException {\r\n        if (airportManager.findAirport(initialLocationAirportCode) != null) {\r\n            if (!airplanes.containsKey(id)) {\r\n                airplanes.put(id, new Airplane(id, capacity, initialLocationAirportCode));\r\n                System.out.println(\"[INFO] Airplane '\" + id + \"' (Capacity: \" + capacity + \") created at \" + initialLocationAirportCode);\r\n            } else {\r\n                System.out.println(\"[WARN] Airplane \" + id + \" already exists. Skipping.\");\r\n            }\r\n        } else {\r\n            System.err.println(\"[ERROR] Cannot add airplane \" + id + \". Initial location \" + initialLocationAirportCode + \" is not a valid airport.\");\r\n        }\r\n    }\r\n\r\n    private void generateRandomFlightBasedOnRules() throws ListException, StackException {\r\n        System.out.println(\"\\n--- Generating new flight request ---\");\r\n\r\n        // Find the 5 airports with the most routes\r\n        DoublyLinkedList allAirportsList = airportManager.getAllAirports();\r\n        if (allAirportsList.isEmpty()) {\r\n            System.out.println(\"[WARN] No airports available to generate flights. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        List<Airport> activeAirports = new ArrayList<>();\r\n        for (int i = 0; i < allAirportsList.size(); i++) {\r\n            Airport airport = (Airport) allAirportsList.get(i);\r\n            if (airport.getStatus() == Airport.AirportStatus.ACTIVE) {\r\n                activeAirports.add(airport);\r\n            }\r\n        }\r\n\r\n        if (activeAirports.isEmpty()) {\r\n            System.out.println(\"[WARN] No active airports to generate flights. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        // Sort by outgoing route count (descending)\r\n        Collections.sort(activeAirports, new Comparator<Airport>() {\r\n            @Override\r\n            public int compare(Airport airport1, Airport airport2) {\r\n                int count1 = routeManager.getGraph().getOutgoingRouteCount(airport1.getCode());\r\n                int count2 = routeManager.getGraph().getOutgoingRouteCount(airport2.getCode());\r\n                return Integer.compare(count2, count1); // Descending order\r\n            }\r\n        });\r\n\r\n        List<Airport> selectedOrigins = new ArrayList<>();\r\n        for (int i = 0; i < Math.min(5, activeAirports.size()); i++) {\r\n            selectedOrigins.add(activeAirports.get(i));\r\n        }\r\n\r\n        if (selectedOrigins.isEmpty()) {\r\n            System.out.println(\"[WARN] Could not select suitable origin airports. Cannot generate flight.\");\r\n            return;\r\n        }\r\n\r\n        // Pick a random origin from the selected top airports\r\n        Airport originAirport = selectedOrigins.get(random.nextInt(selectedOrigins.size()));\r\n        String originCode = originAirport.getCode();\r\n\r\n        // Find a random destination that is not the origin and has a route\r\n        SinglyLinkedList allAirportCodesFromGraph;\r\n        try {\r\n            allAirportCodesFromGraph = routeManager.getGraph().getAllAirportCodes();\r\n        } catch (ListException e) {\r\n            System.err.println(\"[ERROR] Failed to get airport codes from graph: \" + e.getMessage());\r\n            return; // Cannot proceed without airport codes\r\n        }\r\n\r\n\r\n        String destinationCode = null;\r\n        int attempts = 0;\r\n        final int MAX_ATTEMPTS = 50;\r\n\r\n        // Loop to find a valid destination with a route\r\n        while (destinationCode == null || destinationCode.equals(originCode) ||\r\n                routeManager.calculateShortestRoute(originCode, destinationCode) == Integer.MAX_VALUE) {\r\n\r\n            // Check if there are any airport codes to select from\r\n            if (allAirportCodesFromGraph.isEmpty()) {\r\n                System.out.println(\"[WARN] No destination airports available in graph to select from. Cannot generate flight.\");\r\n                return;\r\n            }\r\n\r\n            // Prevent infinite loop if no valid destination can be found\r\n            if (attempts >= MAX_ATTEMPTS) {\r\n                System.out.println(\"[WARN] Failed to find a valid destination with a route from \" + originCode + \" after \" + MAX_ATTEMPTS + \" attempts. Cannot generate flight.\");\r\n                return;\r\n            }\r\n\r\n            // Get a random airport code from the SinglyLinkedList and cast it to String\r\n            destinationCode = (String) allAirportCodesFromGraph.get(random.nextInt(allAirportCodesFromGraph.size()));\r\n            attempts++;\r\n        }\r\n\r\n        // --- MODIFIED LOGIC FOR AIRPLANE SELECTION AND FLIGHT SIMULATION ---\r\n        // Find an IDLE airplane at the origin airport\r\n        Airplane selectedAirplane = null;\r\n        for (Airplane airplane : airplanes.values()) {\r\n            if (airplane.getCurrentLocationAirportCode() != null && // Check if location is not null\r\n                    airplane.getCurrentLocationAirportCode().equals(originCode) &&\r\n                    airplane.getStatus() == AirplaneStatus.IDLE) { // Ensure it's IDLE and at the origin\r\n                selectedAirplane = airplane;\r\n                break; // Found one, use it\r\n            }\r\n        }\r\n\r\n        String flightNumber = \"FL\" + (random.nextInt(900) + 100);\r\n        LocalDateTime departureTime = LocalDateTime.now().plusHours(random.nextInt(12) + 1);\r\n        int capacity;\r\n\r\n        if (selectedAirplane == null) {\r\n            System.out.println(\"[WARN] No IDLE airplane available at \" + originCode + \" for flight to \" + destinationCode + \". Flight will be created but not simulated immediately.\");\r\n            // Create the flight schedule anyway, so it exists and passengers can be assigned\r\n            capacity = 150 + random.nextInt(150); // Default capacity if no plane selected yet\r\n            flightScheduleManager.createFlight(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n\r\n        } else {\r\n            // If an airplane is found and is IDLE, proceed with flight creation\r\n            capacity = selectedAirplane.getCapacity(); // Use selected airplane's capacity\r\n            capacity = random.nextInt(capacity / 2) + capacity / 2; // Adjust capacity relative to selected plane for varied occupancy\r\n\r\n            // Create the flight schedule\r\n            flightScheduleManager.createFlight(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n\r\n            // Now, trigger the flight simulation with the selected airplane\r\n            System.out.println(\"[SIM] Initiating simulation for flight \" + flightNumber + \" with airplane \" + selectedAirplane.getId() + \" from \" + originCode + \" to \" + destinationCode);\r\n            flightScheduleManager.simulateFlight(flightNumber, airportManager, passengerManager, selectedAirplane);\r\n        }\r\n\r\n        // Simulate some passengers buying tickets for the *created* flight (whether simulated or not)\r\n        // This part needs to happen *after* flight creation.\r\n        int passengersBuyingTickets = random.nextInt(capacity / 2) + 1; // Base on the *final* flight capacity\r\n        System.out.println(\"[INFO] Attempting to process tickets for \" + passengersBuyingTickets + \" passengers for flight \" + flightNumber);\r\n        for (int i = 0; i < passengersBuyingTickets; i++) {\r\n            String passengerId = \"100\" + (random.nextInt(5) + 1); // Assuming passenger IDs are 1001-1005\r\n            Passenger p = passengerManager.searchPassenger(passengerId);\r\n            if (p != null) {\r\n                flightScheduleManager.processTicketPurchase(p, originCode, destinationCode);\r\n            } else {\r\n                System.err.println(\"[ERROR] Passenger \" + passengerId + \" not found for ticket purchase simulation.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public void startSimulation(long flightGenerationIntervalSeconds, long simulationDurationSeconds) {\r\n        System.out.println(\"\\n--- Starting Flight Simulation ---\");\r\n        System.out.println(\"Flights will be generated every \" + flightGenerationIntervalSeconds + \" seconds.\");\r\n        System.out.println(\"Simulation will run for \" + simulationDurationSeconds + \" seconds.\");\r\n\r\n        scheduler.scheduleAtFixedRate(() -> {\r\n            try {\r\n                generateRandomFlightBasedOnRules();\r\n            } catch (ListException | StackException e) {\r\n                System.err.println(\"[RUNTIME ERROR] Error generating random flight: \" + e.getMessage());\r\n                // For a scheduled task, you might want more sophisticated error handling\r\n                // For now, it will just log and continue trying on the next interval\r\n            }\r\n        }, 1, flightGenerationIntervalSeconds, TimeUnit.SECONDS);\r\n\r\n        scheduler.schedule(() -> {\r\n            try {\r\n                stopSimulation();\r\n            } catch (ListException e) {\r\n                System.err.println(\"[RUNTIME ERROR] Error during simulation shutdown: \" + e.getMessage());\r\n            }\r\n        }, simulationDurationSeconds, TimeUnit.SECONDS);\r\n    }\r\n\r\n    public void stopSimulation() throws ListException {\r\n        System.out.println(\"\\n--- Stopping Flight Simulation ---\");\r\n        scheduler.shutdown();\r\n        try {\r\n            if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) { // Give tasks 10 seconds to finish\r\n                scheduler.shutdownNow();\r\n                System.out.println(\"[WARN] Forced shutdown of scheduler. Some tasks might not have completed.\");\r\n            }\r\n        } catch (InterruptedException e) {\r\n            scheduler.shutdownNow();\r\n            Thread.currentThread().interrupt();\r\n            System.err.println(\"[ERROR] Simulation shutdown was interrupted.\");\r\n            throw new RuntimeException(\"Simulation shutdown interrupted\", e);\r\n        }\r\n        System.out.println(\"\\n--- Flight Simulation Stopped ---\");\r\n\r\n        System.out.println(\"\\n--- Airplane Flight Histories ---\");\r\n        if (airplanes.isEmpty()) {\r\n            System.out.println(\"No airplanes in the system.\");\r\n        } else {\r\n            airplanes.values().forEach(Airplane::printFlightHistory);\r\n        }\r\n        System.out.println(\"---------------------------------\");\r\n\r\n        System.out.println(\"\\n--- Passenger Flight Histories ---\");\r\n        if (passengerManager.getPassengerCount() == 0) {\r\n            System.out.println(\"No passengers registered or with flight history.\");\r\n        } else {\r\n            // Print histories for the initial passengers\r\n            passengerManager.showFlightHistory(\"1001\");\r\n            passengerManager.showFlightHistory(\"1002\");\r\n            passengerManager.showFlightHistory(\"1003\");\r\n            passengerManager.showFlightHistory(\"1004\");\r\n            passengerManager.showFlightHistory(\"1005\");\r\n        }\r\n        System.out.println(\"----------------------------------\");\r\n\r\n        System.out.println(\"\\n--- Final Airport Status ---\");\r\n        airportManager.listAirports(true, true); // Assuming listAirports shows active airports and queue sizes\r\n        System.out.println(\"\\n--- Final Flight Schedule ---\");\r\n        flightScheduleManager.listAllFlights();\r\n        System.out.println(\"-----------------------------\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            FlightSimulator simulator = new FlightSimulator();\r\n            simulator.startSimulation(10, 60); // Generate every 10s, run for 60s\r\n\r\n        } catch (ListException e) {\r\n            System.err.println(\"[FATAL ERROR] Failed to initialize Flight Simulator due to ListException: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            System.err.println(\"[FATAL ERROR] Failed to initialize Flight Simulator due to IOException (e.g., airports file issue): \" + e.getMessage());\r\n            e.printStackTrace();\r\n        } catch (RuntimeException e) {\r\n            System.err.println(\"[FATAL ERROR] An unexpected runtime error occurred during simulation: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSimulator.java	(date 1749498454914)
@@ -10,8 +10,8 @@
 import ucr.proyectoalgoritmos.Domain.list.ListException;
 import ucr.proyectoalgoritmos.Domain.list.DoublyLinkedList;
 import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // Ensure this is imported for type consistency
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.Domain.stack.StackException;
 import ucr.proyectoalgoritmos.route.RouteManager; // Import RouteManager
 import ucr.proyectoalgoritmos.route.Route; // Import your Route class
Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package\r\n\r\nimport ucr.proyectoalgoritmos.Domain.Circular.CircularDoublyLinkedList;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.Airport;\r\nimport ucr.proyectoalgoritmos.Domain.aeropuetos.AirportManager;\r\nimport ucr.proyectoalgoritmos.Domain.airplane.Airplane;\r\nimport ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList;\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.Domain.stack.StackException;\r\nimport ucr.proyectoalgoritmos.route.RouteManager;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Random;\r\nimport java.util.concurrent.TimeUnit; // For Thread.sleep\r\n\r\npublic class FlightScheduleManager {\r\n    public CircularDoublyLinkedList scheduledFlights; // Stores Flight objects\r\n    private AirportManager airportManager; // Dependency to check airport validity\r\n    private RouteManager routeManager;   // Dependency to get route distances\r\n    private Random random;\r\n\r\n    // A simple waiting list structure: Map<\"Origin-Destination\", SinglyLinkedList<Passenger>>\r\n    private Map<String, SinglyLinkedList> passengerWaitingLists;\r\n\r\n    public FlightScheduleManager(AirportManager airportManager, RouteManager routeManager) {\r\n        this.scheduledFlights = new CircularDoublyLinkedList(); // Initialize the Circular Doubly Linked List\r\n        this.airportManager = airportManager;\r\n        this.routeManager = routeManager;\r\n        this.random = new Random();\r\n        this.passengerWaitingLists = new HashMap<>();\r\n        System.out.println(\"FSM DEBUG: FlightScheduleManager initialized.\");\r\n    }\r\n\r\n    // a. Create flight from an origin airport to a destination\r\n    public void createFlight(String flightNumber, String originCode, String destinationCode,\r\n                             LocalDateTime departureTime, int capacity) throws ListException {\r\n        System.out.println(\"FSM DEBUG: Attempting to create flight \" + flightNumber);\r\n        // Business Rule: No flights to the same airport.\r\n        if (originCode.equalsIgnoreCase(destinationCode)) {\r\n            throw new ListException(\"Cannot create flight from \" + originCode + \" to \" + destinationCode + \": Origin and destination cannot be the same.\");\r\n        }\r\n\r\n        // Basic validation\r\n        if (airportManager.findAirport(originCode) == null) {\r\n            throw new ListException(\"Origin airport \" + originCode + \" does not exist.\");\r\n        }\r\n        if (airportManager.findAirport(destinationCode) == null) {\r\n            throw new ListException(\"Destination airport \" + destinationCode + \" does not exist.\");\r\n        }\r\n        // Check if flight number already exists\r\n        if (findFlight(flightNumber) != null) {\r\n            throw new ListException(\"Flight number \" + flightNumber + \" already exists.\");\r\n        }\r\n\r\n        FlightSchedule newFlight = new FlightSchedule(flightNumber, originCode, destinationCode, departureTime, capacity);\r\n        scheduledFlights.add(newFlight); // Add to the Circular Doubly Linked List\r\n        System.out.println(\"[INFO] Flight created: \" + newFlight.getFlightNumber() + \" from \" + originCode + \" to \" + destinationCode + \". Total scheduled flights: \" + scheduledFlights.size());\r\n    }\r\n\r\n    // 3. Ticket Purchase - Assign passengers to flight\r\n    public void processTicketPurchase(Passenger passenger, String originCode, String destinationCode) throws ListException {\r\n        if (originCode.equalsIgnoreCase(destinationCode)) {\r\n            System.out.println(\"[TICKET] \" + passenger.getId() + \": Cannot book flight to same airport.\");\r\n            return;\r\n        }\r\n\r\n        // Find available flight with capacity\r\n        FlightSchedule availableFlight = null;\r\n\r\n        // Ensure scheduledFlights is not empty before iterating\r\n        if (scheduledFlights.isEmpty()) {\r\n            System.out.println(\"FSM DEBUG: No scheduled flights available for ticket purchase.\");\r\n            // Add to waiting list directly if no flights exist\r\n            System.out.println(\"[TICKET] No flights exist at all. Passenger \" + passenger.getId() + \" added to waiting list for \" + originCode + \"-\" + destinationCode + \".\");\r\n            String routeKey = originCode + \"-\" + destinationCode;\r\n            SinglyLinkedList waitingList = passengerWaitingLists.computeIfAbsent(routeKey, k -> new SinglyLinkedList());\r\n            waitingList.add(passenger);\r\n            return;\r\n        }\r\n\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getOriginAirportCode().equalsIgnoreCase(originCode) &&\r\n                    flight.getDestinationAirportCode().equalsIgnoreCase(destinationCode) &&\r\n                    flight.getStatus() == FlightSchedule.FlightStatus.SCHEDULED &&\r\n                    flight.getAvailableSeats() > 0) {\r\n                availableFlight = flight;\r\n                break; // Found one, take the first available\r\n            }\r\n        }\r\n\r\n        if (availableFlight != null) {\r\n            // Assign passenger to the flight\r\n            if (availableFlight.assignPassenger(passenger)) {\r\n                System.out.println(\"[TICKET] Passenger \" + passenger.getId() + \" assigned to flight \" + availableFlight.getFlightNumber());\r\n            } else {\r\n                System.out.println(\"[TICKET] Error assigning passenger \" + passenger.getId() + \" to flight \" + availableFlight.getFlightNumber() + \" (unexpectedly full).\");\r\n            }\r\n        } else {\r\n            // If no capacity, add to waiting list\r\n            System.out.println(\"[TICKET] No direct flight from \" + originCode + \" to \" + destinationCode + \" with available seats. Passenger \" + passenger.getId() + \" added to waiting list.\");\r\n            String routeKey = originCode + \"-\" + destinationCode;\r\n            // Get the list, or create it if it doesn't exist\r\n            SinglyLinkedList waitingList = passengerWaitingLists.computeIfAbsent(routeKey, k -> new SinglyLinkedList());\r\n            waitingList.add(passenger);\r\n        }\r\n    }\r\n\r\n    // Method to check waiting lists and assign passengers to new flights\r\n    public void assignWaitingPassengersToNewFlights(String originCode, String destinationCode) throws ListException {\r\n        String routeKey = originCode + \"-\" + destinationCode;\r\n        SinglyLinkedList waitingList = passengerWaitingLists.get(routeKey);\r\n\r\n        if (waitingList == null || waitingList.isEmpty()) {\r\n            System.out.println(\"FSM DEBUG: No waiting passengers for route \" + routeKey);\r\n            return; // No waiting passengers for this route\r\n        }\r\n\r\n        // Find a suitable flight that is SCHEDULED and has capacity\r\n        FlightSchedule targetFlight = null;\r\n\r\n        // Check if there are any scheduled flights before attempting to find one\r\n        if (scheduledFlights.isEmpty()) {\r\n            System.out.println(\"FSM DEBUG: No scheduled flights available to assign waiting passengers to.\");\r\n            return;\r\n        }\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getOriginAirportCode().equalsIgnoreCase(originCode) &&\r\n                    flight.getDestinationAirportCode().equalsIgnoreCase(destinationCode) &&\r\n                    flight.getStatus() == FlightSchedule.FlightStatus.SCHEDULED &&\r\n                    flight.getAvailableSeats() > 0) {\r\n                targetFlight = flight;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (targetFlight != null) {\r\n            System.out.println(\"[WAITLIST] Attempting to assign waiting passengers for \" + routeKey + \" to flight \" + targetFlight.getFlightNumber());\r\n            int assignedCount = 0;\r\n            while (!waitingList.isEmpty() && targetFlight.getAvailableSeats() > 0) {\r\n                Passenger waitingPassenger = (Passenger) waitingList.getFirst(); // Get first in queue\r\n                if (waitingPassenger == null) { // Defensive check\r\n                    System.err.println(\"FSM ERROR: Waiting list returned null passenger for \" + routeKey);\r\n                    waitingList.removeFirst(); // Try to clear the null entry if it somehow got there\r\n                    continue;\r\n                }\r\n                if (targetFlight.assignPassenger(waitingPassenger)) {\r\n                    waitingList.removeFirst(); // Remove from waiting list if assigned\r\n                    assignedCount++;\r\n                } else {\r\n                    System.out.println(\"[WAITLIST] Flight became full unexpectedly during assignment for \" + waitingPassenger.getId());\r\n                    break;\r\n                }\r\n            }\r\n            System.out.println(\"[WAITLIST] \" + assignedCount + \" passengers assigned from waiting list for \" + routeKey + \". Remaining: \" + waitingList.size());\r\n        } else {\r\n            System.out.println(\"[WAITLIST] No suitable flight found for waiting passengers on route \" + routeKey);\r\n        }\r\n    }\r\n\r\n    // c. Show active and completed flights\r\n    public void listFlights(FlightSchedule.FlightStatus statusFilter) throws ListException {\r\n        System.out.println(\"FSM DEBUG: listFlights() called. Total scheduled flights: \" + scheduledFlights.size());\r\n        if (scheduledFlights.isEmpty()) {\r\n            System.out.println(\"No flights to list.\");\r\n            return;\r\n        }\r\n        System.out.println(\"\\n--- \" + (statusFilter != null ? statusFilter.name() : \"All\") + \" Flights ---\");\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (statusFilter == null || flight.getStatus() == statusFilter) {\r\n                System.out.println(flight);\r\n            }\r\n        }\r\n\r\n        System.out.println(\"--------------------------------\");\r\n    }\r\n\r\n    public void listAllFlights() throws ListException {\r\n        listFlights(null); // Show all flights\r\n    }\r\n\r\n    // d. Simulate flight (with route and passenger boarding)\r\n    // This method now also handles updating passenger history\r\n    public void simulateFlight(String flightNumber, AirportManager airportManager, PassengerManager passengerManager, Airplane airplane) throws ListException, StackException {\r\n        System.out.println(\"FSM DEBUG: simulateFlight(\" + flightNumber + \") called.\");\r\n        FlightSchedule flight = findFlight(flightNumber);\r\n        if (flight == null) {\r\n            throw new ListException(\"Flight \" + flightNumber + \" not found for simulation. Scheduled flights count: \" + scheduledFlights.size());\r\n        }\r\n\r\n        if (flight.getStatus() != FlightSchedule.FlightStatus.SCHEDULED) {\r\n            System.out.println(\"[SIM] Flight \" + flightNumber + \" is not in SCHEDULED status. Cannot simulate.\");\r\n            return;\r\n        }\r\n\r\n        // --- 4. Flight Simulation: Execute Dijkstra to find the shortest route ---\r\n        int routeDuration = routeManager.calculateShortestRoute(\r\n                flight.getOriginAirportCode(),\r\n                flight.getDestinationAirportCode());\r\n\r\n        if (routeDuration == Integer.MAX_VALUE) {\r\n            flight.setStatus(FlightSchedule.FlightStatus.CANCELLED); // Mark as cancelled if unreachable\r\n            System.err.println(\"[SIM ERROR] No route found from \" + flight.getOriginAirportCode() + \" to \" + flight.getDestinationAirportCode() + \". Flight \" + flightNumber + \" cancelled.\");\r\n            // Consider removing the cancelled flight from scheduledFlights if it won't be retried\r\n            // scheduledFlights.remove(flight); // Only if you want to remove it\r\n            throw new ListException(\"No route found from \" + flight.getOriginAirportCode() + \" to \" + flight.getDestinationAirportCode() + \". Flight \" + flightNumber + \" cancelled.\");\r\n        }\r\n\r\n        System.out.println(\"\\n--- Simulating Flight \" + flightNumber + \" ---\");\r\n        System.out.println(\"From: \" + flight.getOriginAirportCode() + \" (\" + airportManager.findAirport(flight.getOriginAirportCode()).getName() + \")\");\r\n        System.out.println(\"To: \" + flight.getDestinationAirportCode() + \" (\" + airportManager.findAirport(flight.getDestinationAirportCode()).getName() + \")\");\r\n        System.out.println(\"Occupancy: \" + flight.getOccupancy() + \"/\" + flight.getCapacity());\r\n        System.out.println(\"Estimated flight duration: \" + routeDuration + \" minutes\");\r\n\r\n        // Update airport departures board (optional, but good for realism)\r\n        Airport originAirport = airportManager.findAirport(flight.getOriginAirportCode());\r\n        if (originAirport != null) {\r\n            // Assuming removeFlightFromBoard expects a FlightSchedule object\r\n            // You might need to adjust Airport class if it's not ready for FlightSchedule\r\n            // originAirport.removeFlightFromBoard(flight);\r\n            System.out.println(\"FSM INFO: Flight \" + flightNumber + \" departed from \" + originAirport.getName());\r\n        }\r\n\r\n        airplane.boardPassengers(flight.getOccupancy()); // Transfer assigned passengers from Flight object to Airplane object\r\n\r\n        flight.setStatus(FlightSchedule.FlightStatus.ACTIVE);\r\n        airplane.takeOff(); // Airplane takes off\r\n\r\n        // --- Console Animation Logic ---\r\n        System.out.println(\"\\n-----------------------------------------------------\");\r\n        System.out.println(\"FLIGHT IN PROGRESS: \" + flight.getFlightNumber());\r\n        System.out.print(flight.getOriginAirportCode() + \" \");\r\n\r\n        int animationSteps = 30;\r\n        long totalAnimationTimeMs = routeDuration * 10L; // Simulate 10ms per minute of flight\r\n        long sleepTimePerStep = totalAnimationTimeMs / animationSteps;\r\n        if (sleepTimePerStep == 0) sleepTimePerStep = 1;\r\n\r\n        for (int i = 0; i < animationSteps; i++) {\r\n            try {\r\n                System.out.print(\">\");\r\n                if (i == animationSteps / 2) {\r\n                    System.out.print(\"✈\uFE0F\");\r\n                }\r\n                TimeUnit.MILLISECONDS.sleep(sleepTimePerStep);\r\n            } catch (InterruptedException e) {\r\n                Thread.currentThread().interrupt();\r\n                System.err.println(\"[SIM] Flight animation interrupted for \" + flightNumber + \".\");\r\n                flight.setStatus(FlightSchedule.FlightStatus.CANCELLED);\r\n                System.out.println(\"\\n-----------------------------------------------------\");\r\n                return;\r\n            }\r\n        }\r\n        System.out.println(\" \" + flight.getDestinationAirportCode());\r\n        System.out.println(\"-----------------------------------------------------\\n\");\r\n        // --- END Console Animation Logic ---\r\n\r\n        // --- 4. Flight Simulation: Upon arrival, empty the airplane's stack and restart the process. ---\r\n        flight.setStatus(FlightSchedule.FlightStatus.COMPLETED);\r\n        System.out.println(\"[SIM] Flight \" + flightNumber + \" has landed at \" + flight.getDestinationAirportCode() + \"!\");\r\n\r\n        // Create the history Flight object for the airplane and passengers\r\n        // NOTE: Ensure FlightHistory is a separate class or record if it's meant for history.\r\n        // If FlightSchedule also serves as history, then this object might not be needed.\r\n        // Assuming FlightHistory is distinct from FlightSchedule for historical records.\r\n        FlightHistory historyFlight =\r\n                new FlightHistory(\r\n                        flight.getFlightNumber(), // Add flight number to history for better tracking\r\n                        flight.getOriginAirportCode(),\r\n                        flight.getDestinationAirportCode(),\r\n                        flight.getOccupancy(),\r\n                        flight.getDepartureTime(),\r\n                        LocalDateTime.now(), // Arrival time is now\r\n                        airplane.getId());\r\n\r\n        // Update each passenger's flight history *before* emptying the flight's assigned passenger list\r\n        SinglyLinkedList passengersOnThisFlight = flight.getAssignedPassengers();\r\n        if (passengersOnThisFlight != null && !passengersOnThisFlight.isEmpty()) {\r\n            for (int i = 0; i < passengersOnThisFlight.size(); i++) {\r\n                try {\r\n                    Passenger p = (Passenger) passengersOnThisFlight.get(i);\r\n                    passengerManager.addFlightToPassengerHistory(p.getId(), historyFlight);\r\n                } catch (ListException e) {\r\n                    System.err.println(\"FSM ERROR: Could not get passenger from assigned list: \" + e.getMessage());\r\n                }\r\n            }\r\n        } else {\r\n            System.out.println(\"FSM DEBUG: No passengers on flight \" + flightNumber + \" to update history for.\");\r\n        }\r\n\r\n\r\n        flight.emptyPassengers(); // Clears assignedPassengers list on the current FlightSchedule object\r\n        airplane.land(flight.getDestinationAirportCode(), historyFlight); // Empties airplane's passenger count, adds flight to airplane's history\r\n\r\n        // Remove the completed flight from the scheduledFlights list (if you want to track active vs. completed)\r\n        // If you want to keep all flights in `scheduledFlights` and filter by status, don't remove here.\r\n        // If `scheduledFlights` is only for *pending* flights, then remove it.\r\n        // Let's assume you want to remove it from `scheduledFlights` if it's completed and no longer 'scheduled'.\r\n        try {\r\n            boolean removed = scheduledFlights.remove(flight);\r\n            if (removed) {\r\n                System.out.println(\"FSM INFO: Flight \" + flightNumber + \" removed from scheduled flights list after completion. Remaining scheduled flights: \" + scheduledFlights.size());\r\n            } else {\r\n                System.err.println(\"FSM ERROR: Flight \" + flightNumber + \" not found in scheduled flights list for removal after completion.\");\r\n            }\r\n        } catch (ListException e) {\r\n            System.err.println(\"FSM ERROR: Could not remove completed flight \" + flightNumber + \" from scheduled flights: \" + e.getMessage());\r\n        }\r\n\r\n        // Assign waiting passengers to potentially new future flights (if you have them)\r\n        // This makes sense if the arrival frees up resources or triggers new flight creation.\r\n        // If it's for *this* route, it should be done after the flight itself is completed.\r\n        assignWaitingPassengersToNewFlights(flight.getOriginAirportCode(), flight.getDestinationAirportCode());\r\n    }\r\n\r\n    // Helper method to find a flight by number\r\n    public FlightSchedule findFlight(String flightNumber) throws ListException {\r\n        if (scheduledFlights.isEmpty()) {\r\n            return null;\r\n        }\r\n\r\n        for (int i = 0; i < scheduledFlights.size(); i++) {\r\n            FlightSchedule flight = (FlightSchedule) scheduledFlights.get(i);\r\n            if (flight.getFlightNumber().equalsIgnoreCase(flightNumber)) {\r\n                return flight;\r\n            }\r\n        }\r\n\r\n        return null; // Not found\r\n    }\r\n\r\n    // Changed return type to FlightSchedule as scheduledFlights holds FlightSchedule objects\r\n    public FlightSchedule getFlightScheduleByIndex(int index) throws ListException {\r\n        if (index < 0 || index >= scheduledFlights.size()) {\r\n            throw new ListException(\"Flight index out of bounds: \" + index + \", List size: \" + scheduledFlights.size());\r\n        }\r\n        return (FlightSchedule) scheduledFlights.get(index);\r\n    }\r\n\r\n    // New helper to get a random scheduled flight\r\n    public FlightSchedule getRandomScheduledFlight() throws ListException {\r\n        if (scheduledFlights.isEmpty()) {\r\n            System.out.println(\"FSM DEBUG: No scheduled flights available to pick a random one.\");\r\n            return null; // No flights to return\r\n        }\r\n        int randomIndex = random.nextInt(scheduledFlights.size());\r\n        return (FlightSchedule) scheduledFlights.get(randomIndex);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightScheduleManager.java	(date 1749498454944)
@@ -7,8 +7,8 @@
 import ucr.proyectoalgoritmos.Domain.airplane.Airplane;
 import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList;
 import ucr.proyectoalgoritmos.Domain.list.ListException;
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.Domain.stack.StackException;
 import ucr.proyectoalgoritmos.route.RouteManager;
 
Index: src/main/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.Archivos;\r\n\r\nimport com.google.gson.JsonArray;\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonObject;\r\nimport com.google.gson.JsonParser;\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.util.Utility;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\n\r\npublic class PassengerData {\r\n\r\n    private PassengerManager passengerManager;\r\n    private int minTotalPassengers;\r\n\r\n\r\n\r\n    public PassengerData(PassengerManager passengerManager , int minTotalPassengers){\r\n        this.passengerManager = passengerManager;\r\n        this.minTotalPassengers = minTotalPassengers;\r\n    }\r\n\r\n    //Cargar los pasajeros\r\n    public void loadPassengersFromJson(String filePath , int Id){\r\n\r\n        System.out.println(\"Loading passengers\");\r\n        boolean loadedFromJson = false;\r\n        int passengersLoaded = 0;\r\n\r\n        try{\r\n\r\n            String content = new String(Files.readAllBytes(Paths.get(filePath)));\r\n            JsonElement parsedElement = JsonParser.parseString(content);\r\n            JsonObject jsonObject = parsedElement.getAsJsonObject();\r\n            JsonArray passengersArray = jsonObject.getAsJsonArray(\"passengers\");\r\n\r\n            if (passengersArray != null){\r\n\r\n                for (int i = 0; i < passengersArray.size(); i++) {\r\n\r\n                    JsonObject passengerJson = passengersArray.get(i).getAsJsonObject();\r\n                    String id = passengerJson.has(\"id\") ? passengerJson.get(\"id\").getAsString() : Utility.RandomId();\r\n                    String name = passengerJson.get(\"name\").getAsString();\r\n                    String nationality = passengerJson.get(\"nationality\").getAsString();\r\n\r\n                    passengerManager.registerPassenger(id , name , nationality);\r\n                    passengersLoaded ++;\r\n\r\n                }\r\n\r\n                loadedFromJson = true;\r\n\r\n            }\r\n\r\n        } catch (IOException | ListException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n        int currentPassengerCount = passengerManager.getPassengerCount();\r\n        int passengersToGenerate = minTotalPassengers -currentPassengerCount;\r\n\r\n        if (passengersToGenerate > 0) {\r\n\r\n            for (int i = 0 ;i<passengersToGenerate; i++){\r\n\r\n                String id = Utility.RandomId();\r\n                String name = Utility.RandomNames();\r\n                String nationality = Utility.RandomNationalities();\r\n\r\n                try {\r\n                    passengerManager.registerPassenger(id , name , nationality);\r\n                } catch (ListException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerData.java b/src/main/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerData.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerData.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerData.java	(date 1749498569798)
@@ -5,7 +5,7 @@
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParser;
 import ucr.proyectoalgoritmos.Domain.list.ListException;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.util.Utility;
 
 import java.io.IOException;
Index: src/test/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerDataTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.Archivos;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException;\r\nimport ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;\r\nimport ucr.proyectoalgoritmos.util.Utility;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nclass PassengerDataTest {\r\n\r\n    private static final int minTotalPassengers = 25 ;\r\n\r\n    @Test\r\n    void test(){\r\n\r\n        PassengerManager passengerManager =new PassengerManager();\r\n        PassengerData passengerData = new PassengerData(passengerManager , minTotalPassengers);\r\n\r\n\r\n        try {\r\n\r\n            for (int i = 0; i < 5; i++) {\r\n\r\n                passengerManager.registerPassenger(Utility.RandomId() , Utility.RandomNames() , Utility.RandomNationalities());\r\n\r\n            }\r\n\r\n        } catch (ListException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n\r\n        System.out.println(\"PASSENGER MANAGEMENT\");\r\n        passengerData.loadPassengersFromJson(\"data/passengers.json\" , minTotalPassengers);\r\n        System.out.println(passengerManager.passengers.inOrder());\r\n\r\n\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerDataTest.java b/src/test/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerDataTest.java
--- a/src/test/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerDataTest.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/test/java/ucr/proyectoalgoritmos/Domain/Archivos/PassengerDataTest.java	(date 1749498569813)
@@ -2,7 +2,7 @@
 
 import org.junit.jupiter.api.Test;
 import ucr.proyectoalgoritmos.Domain.list.ListException;
-import ucr.proyectoalgoritmos.Domain.passanger.PassengerManager;
+import ucr.proyectoalgoritmos.Domain.passenger.PassengerManager;
 import ucr.proyectoalgoritmos.util.Utility;
 
 import static org.junit.jupiter.api.Assertions.*;
Index: src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.Domain.flight; // Adjust package\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\nimport ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // For passengers assigned to this flight\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger; // For storing actual passengers\r\nimport ucr.proyectoalgoritmos.Domain.list.ListException; // Import ListException\r\n\r\npublic class FlightSchedule implements Comparable<FlightSchedule> { // Implement Comparable for sorting/searching\r\n    private String flightNumber; // e.g., AA123\r\n    private String originAirportCode;\r\n    private String destinationAirportCode;\r\n    private LocalDateTime departureTime;\r\n    private int capacity;\r\n    private int occupancy; // Current number of passengers assigned/boarded\r\n    private FlightStatus status; // Enum for Scheduled, Active, Completed, Cancelled\r\n    private SinglyLinkedList assignedPassengers; // List of Passenger objects assigned to this flight\r\n\r\n    public FlightSchedule(String flightNumber, String originAirportCode, String destinationCode,\r\n                          LocalDateTime departureTime, int capacity) {\r\n        this.flightNumber = flightNumber;\r\n        this.originAirportCode = originAirportCode;\r\n        this.destinationAirportCode = destinationCode; // Corrected parameter name\r\n        this.departureTime = departureTime;\r\n        this.capacity = capacity;\r\n        this.occupancy = 0; // Starts empty\r\n        this.status = FlightStatus.SCHEDULED; // Initial status\r\n        this.assignedPassengers = new SinglyLinkedList(); // Initialize list of passengers\r\n        System.out.println(\"FS DEBUG: Flight \" + flightNumber + \" created with capacity \" + capacity);\r\n    }\r\n\r\n    // --- Getters ---\r\n    public String getFlightNumber() { return flightNumber; }\r\n    public String getOriginAirportCode() { return originAirportCode; }\r\n    public String getDestinationAirportCode() { return destinationAirportCode; }\r\n    public LocalDateTime getDepartureTime() { return departureTime; }\r\n    public int getCapacity() { return capacity; }\r\n    public int getOccupancy() { return occupancy; }\r\n    public FlightStatus getStatus() { return status; }\r\n    public int getAvailableSeats() { return capacity - occupancy; }\r\n    public SinglyLinkedList getAssignedPassengers() { return assignedPassengers; } // Returns the actual list\r\n\r\n    // --- Setters (for updatable attributes or status changes) ---\r\n    public void setDepartureTime(LocalDateTime departureTime) { this.departureTime = departureTime; }\r\n    public void setStatus(FlightStatus status) {\r\n        System.out.println(\"FS DEBUG: Flight \" + flightNumber + \" status changed from \" + this.status + \" to \" + status);\r\n        this.status = status;\r\n    }\r\n\r\n    /**\r\n     * Assigns a passenger to this flight if there are available seats.\r\n     * @param passenger The Passenger object to assign.\r\n     * @return true if the passenger was successfully assigned, false otherwise (e.g., flight is full).\r\n     */\r\n    public boolean assignPassenger(Passenger passenger) { // Assign one passenger\r\n        if (passenger == null) {\r\n            System.err.println(\"[FLIGHT \" + flightNumber + \"] Cannot assign a null passenger.\");\r\n            return false;\r\n        }\r\n        if (occupancy < capacity) {\r\n            this.assignedPassengers.add(passenger); // Add passenger object to list\r\n            occupancy++;\r\n            System.out.println(\"[FLIGHT \" + flightNumber + \"] Passenger \" + passenger.getId() + \" assigned. Occupancy: \" + occupancy + \"/\" + capacity);\r\n            return true;\r\n        } else {\r\n            System.out.println(\"[FLIGHT \" + flightNumber + \"] Cannot assign passenger \" + passenger.getId() + \". Flight is full (Occupancy: \" + occupancy + \"/\" + capacity + \").\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears all assigned passengers and resets occupancy to zero.\r\n     * This method is typically called upon flight completion.\r\n     */\r\n    public void emptyPassengers() {\r\n        System.out.println(\"FS DEBUG: Emptying passengers for flight \" + flightNumber + \". Before: \" + occupancy + \" passengers.\");\r\n        this.occupancy = 0;\r\n        this.assignedPassengers.clear(); // Clear the list of assigned passengers\r\n        System.out.println(\"[FLIGHT \" + flightNumber + \"] Passengers emptied. After: \" + occupancy + \" passengers.\");\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\r\n        return \"Flight [Num: \" + flightNumber +\r\n                \", From: \" + originAirportCode +\r\n                \", To: \" + destinationAirportCode +\r\n                \", Depart: \" + departureTime.format(formatter) +\r\n                \", Cap: \" + capacity +\r\n                \", Occ: \" + occupancy +\r\n                \", Status: \" + status +\r\n                \"]\";\r\n    }\r\n\r\n    /**\r\n     * Compares this FlightSchedule object with another based on their flight numbers.\r\n     * @param other The other FlightSchedule object to compare to.\r\n     * @return A negative integer, zero, or a positive integer as this flight number\r\n     * is less than, equal to, or greater than the specified flight number.\r\n     */\r\n    @Override\r\n    public int compareTo(FlightSchedule other) {\r\n        // Null checks for robustness\r\n        if (other == null) return 1; // This object is greater than null\r\n        if (this.flightNumber == null && other.flightNumber == null) return 0;\r\n        if (this.flightNumber == null) return -1; // Null flight number is \"less\" than a non-null one\r\n        if (other.flightNumber == null) return 1;\r\n\r\n        return this.flightNumber.compareTo(other.flightNumber);\r\n    }\r\n\r\n    // Enum for flight status\r\n    public enum FlightStatus {\r\n        SCHEDULED,\r\n        ACTIVE,    // In transit\r\n        COMPLETED,\r\n        CANCELLED\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/flight/FlightSchedule.java	(date 1749498455130)
@@ -3,7 +3,7 @@
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import ucr.proyectoalgoritmos.Domain.list.SinglyLinkedList; // For passengers assigned to this flight
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger; // For storing actual passengers
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger; // For storing actual passengers
 import ucr.proyectoalgoritmos.Domain.list.ListException; // Import ListException
 
 public class FlightSchedule implements Comparable<FlightSchedule> { // Implement Comparable for sorting/searching
Index: src/main/java/ucr/proyectoalgoritmos/util/Utility.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ucr.proyectoalgoritmos.util;\r\n\r\nimport ucr.proyectoalgoritmos.Domain.passanger.Passenger; // Import your Passenger class\r\n\r\nimport java.text.DecimalFormat;\r\nimport java.util.Random;\r\n\r\npublic class Utility {\r\n\r\n    static {\r\n        // static initialization block, currently empty\r\n    }\r\n\r\n    public static String format(double value){\r\n        return new DecimalFormat(\"###,###,###.##\").format(value);\r\n    }\r\n    public static String $format(double value){\r\n        return new DecimalFormat(\"$###,###,###.##\").format(value);\r\n    }\r\n\r\n    public static void fill(int[] a, int bound) {\r\n        for (int i = 0; i < a.length; i++) {\r\n            a[i] = new Random().nextInt(bound);\r\n        }\r\n    }\r\n\r\n    public static int random(int bound) {\r\n        return new Random().nextInt(bound);\r\n    }\r\n\r\n    public static int compare(Object a, Object b) {\r\n        // Handle null cases explicitly for robustness\r\n        if (a == null && b == null) return 0;\r\n        if (a == null) return -1; // a is \"less\" than b if a is null\r\n        if (b == null) return 1;  // a is \"greater\" than b if b is null\r\n\r\n        switch (instanceOf(a, b)){\r\n            case \"Integer\":\r\n                Integer int1 = (Integer)a; Integer int2 = (Integer)b;\r\n                return int1 < int2 ? -1 : int1 > int2 ? 1 : 0; //0 == equal\r\n            case \"String\":\r\n                String st1 = (String)a; String st2 = (String)b;\r\n                return st1.compareTo(st2); // compareTo already returns -1, 0, or 1\r\n            case \"Character\":\r\n                Character c1 = (Character)a; Character c2 = (Character)b;\r\n                return c1.compareTo(c2); // compareTo already returns -1, 0, or 1\r\n            case \"Passenger\": // --- ADDED THIS CASE ---\r\n                Passenger p1 = (Passenger) a;\r\n                Passenger p2 = (Passenger) b;\r\n                return p1.getId().compareTo(p2.getId()); // Compare passengers by their ID\r\n            // case \"EdgeWeight\":\r\n            //    EdgeWeight ew1 = (EdgeWeight) a ; EdgeWeight ew2 = (EdgeWeight) b;\r\n            //    return compare(ew1.getEdge(), ew2.getEdge());\r\n        }\r\n        return 2; // Unknown type comparison - indicates a problem\r\n    }\r\n\r\n    private static String instanceOf(Object a, Object b) {\r\n        if(a instanceof Integer && b instanceof Integer) return \"Integer\";\r\n        if(a instanceof String && b instanceof String) return \"String\";\r\n        if(a instanceof Character && b instanceof Character) return \"Character\";\r\n        if (a instanceof Passenger && b instanceof Passenger) return \"Passenger\"; // --- ADDED THIS LINE ---\r\n        //if (a instanceof EdgeWeight && b instanceof EdgeWeight) return \"EdgeWeight\";\r\n        return \"Unknown\";\r\n    }\r\n\r\n    public static int maxArray(int[] a) {\r\n        int max = a[0]; //first element\r\n        for (int i = 1; i < a.length; i++) {\r\n            if(a[i]>max){\r\n                max=a[i];\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public static int[] getIntegerArray(int n) {\r\n        int[] newArray = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            newArray[i] = random(9999);\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n\r\n    public static int[] copyArray(int[] a) {\r\n        int n = a.length;\r\n        int[] newArray = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            newArray[i] = a[i];\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n    public static String show(int[] a, int n) {\r\n        String result=\"\";\r\n        for (int i = 0; i < n; i++) {\r\n            result+=a[i]+\" \";\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public static String RandomAlphabet() {\r\n        String[] Alphabet = {\r\n                \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\",\r\n                \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\r\n        };\r\n\r\n        Random random = new Random();\r\n        int randomIndex = random.nextInt(Alphabet.length);\r\n        return Alphabet[randomIndex];\r\n    }\r\n\r\n    public static String RandomNames(){\r\n        String [] names = { \"Sofía\", \"Mateo\", \"Valentina\", \"Lucas\", \"Isabella\",\r\n                \"Benjamín\", \"Emma\", \"Sebastián\", \"Camila\", \"Diego\",\r\n                \"Mariana\", \"Alejandro\", \"Daniela\", \"Julián\", \"Natalia\"};\r\n\r\n        String[] lastNames = {\r\n                \"García\", \"Martínez\", \"López\", \"Rodríguez\", \"Hernández\",\r\n                \"Pérez\", \"González\", \"Ramírez\", \"Sánchez\", \"Torres\",\r\n                \"Flores\", \"Díaz\", \"Vázquez\", \"Morales\", \"Cruz\"\r\n        };\r\n\r\n        Random random = new Random();\r\n        int randomIndex = random.nextInt(names.length);\r\n        int randomEs = random.nextInt(lastNames.length);\r\n        return names[randomIndex] +  \" \" + lastNames[randomEs];\r\n    }\r\n\r\n    public static String RandomNationalities(){\r\n\r\n        String[] nationalities = {\r\n                \"Mexicana\", \"Argentina\", \"Española\", \"Colombiana\", \"Chilena\",\r\n                \"Peruana\", \"Brasileña\", \"Estadounidense\", \"Canadiense\", \"Italiana\",\r\n                \"Francesa\", \"Alemana\", \"Japonesa\", \"China\", \"India\"\r\n        };\r\n\r\n        Random random = new Random();\r\n        int randomIndex = random.nextInt(nationalities.length);\r\n        return nationalities[randomIndex] ;\r\n    }\r\n\r\n    public static String RandomId() {\r\n\r\n        Random random = new Random();\r\n        String characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\r\n        char[] idChars = new char[8];\r\n\r\n        for (int i = 0; i < 8; i++) {\r\n            idChars[i] = characters.charAt(random.nextInt(characters.length()));\r\n        }\r\n        return new String(idChars);\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/util/Utility.java b/src/main/java/ucr/proyectoalgoritmos/util/Utility.java
--- a/src/main/java/ucr/proyectoalgoritmos/util/Utility.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/util/Utility.java	(date 1749498455171)
@@ -1,6 +1,6 @@
 package ucr.proyectoalgoritmos.util;
 
-import ucr.proyectoalgoritmos.Domain.passanger.Passenger; // Import your Passenger class
+import ucr.proyectoalgoritmos.Domain.passenger.Passenger; // Import your Passenger class
 
 import java.text.DecimalFormat;
 import java.util.Random;
Index: src/main/java/module-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module ucr.proyectoalgoritmos {\r\n    requires javafx.controls;\r\n    requires javafx.fxml;\r\n    requires com.google.gson;\r\n\r\n    // Open packages for reflection (Gson needs access to private fields)\r\n    opens ucr.proyectoalgoritmos.Domain.aeropuetos to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.airplane to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.passanger to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.flight;\r\n    opens ucr.proyectoalgoritmos.Domain.list to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.queue to com.google.gson; // <--- ADD THIS NEW CRITICAL LINE!\r\n    opens ucr.proyectoalgoritmos.route to com.google.gson;\r\n    opens ucr.proyectoalgoritmos.Domain.stack to com.google.gson;\r\n    // If your Node class is in a separate package (e.g., if Node is generic and used by multiple structures\r\n    // and its own package), you might need an opens for that package too.\r\n    // If your queue's Node is inside the Domain.queue package, the above line covers it.\r\n\r\n    // Open/Export packages for JavaFX and general access\r\n    opens ucr.proyectoalgoritmos to javafx.fxml;\r\n    exports ucr.proyectoalgoritmos;\r\n\r\n    exports ucr.proyectoalgoritmos.Controller;\r\n    opens ucr.proyectoalgoritmos.Controller to javafx.fxml;\r\n\r\n    // Export your domain packages if other modules might use them\r\n    exports ucr.proyectoalgoritmos.Domain.aeropuetos;\r\n    exports ucr.proyectoalgoritmos.Domain.airplane;\r\n    exports ucr.proyectoalgoritmos.Domain.flight;\r\n    exports ucr.proyectoalgoritmos.Domain.list;\r\n    exports ucr.proyectoalgoritmos.Domain.passanger; // Typo 'passanger' vs 'passenger' - check your actual package name!\r\n//    exports ucr.proyectoalgoritmos.Domain.passenger; // If you refactored it\r\n    exports ucr.proyectoalgoritmos.Domain.queue; // <--- Make sure this is exported too\r\n    exports ucr.proyectoalgoritmos.Domain.stack;\r\n    exports ucr.proyectoalgoritmos.route;\r\n    exports ucr.proyectoalgoritmos.util;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/module-info.java b/src/main/java/module-info.java
--- a/src/main/java/module-info.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/module-info.java	(date 1749498455191)
@@ -6,7 +6,7 @@
     // Open packages for reflection (Gson needs access to private fields)
     opens ucr.proyectoalgoritmos.Domain.aeropuetos to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.airplane to com.google.gson;
-    opens ucr.proyectoalgoritmos.Domain.passanger to com.google.gson;
+    opens ucr.proyectoalgoritmos.Domain.passenger to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.flight;
     opens ucr.proyectoalgoritmos.Domain.list to com.google.gson;
     opens ucr.proyectoalgoritmos.Domain.queue to com.google.gson; // <--- ADD THIS NEW CRITICAL LINE!
@@ -28,7 +28,7 @@
     exports ucr.proyectoalgoritmos.Domain.airplane;
     exports ucr.proyectoalgoritmos.Domain.flight;
     exports ucr.proyectoalgoritmos.Domain.list;
-    exports ucr.proyectoalgoritmos.Domain.passanger; // Typo 'passanger' vs 'passenger' - check your actual package name!
+    exports ucr.proyectoalgoritmos.Domain.passenger; // Typo 'passanger' vs 'passenger' - check your actual package name!
 //    exports ucr.proyectoalgoritmos.Domain.passenger; // If you refactored it
     exports ucr.proyectoalgoritmos.Domain.queue; // <--- Make sure this is exported too
     exports ucr.proyectoalgoritmos.Domain.stack;
Index: src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java
rename from src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java
rename to src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/Passenger.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/Passenger.java	(date 1749498455014)
@@ -1,4 +1,4 @@
-package ucr.proyectoalgoritmos.Domain.passanger;
+package ucr.proyectoalgoritmos.Domain.passenger;
 
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistory;
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistoryList;
Index: src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java
rename from src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java
rename to src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java
--- a/src/main/java/ucr/proyectoalgoritmos/Domain/passanger/PassengerManager.java	(revision b098022fcc038dc282396daa2b44e01b69ce0bb7)
+++ b/src/main/java/ucr/proyectoalgoritmos/Domain/passenger/PassengerManager.java	(date 1749498455092)
@@ -1,4 +1,4 @@
-package ucr.proyectoalgoritmos.Domain.passanger;
+package ucr.proyectoalgoritmos.Domain.passenger;
 
 import ucr.proyectoalgoritmos.Domain.AVL; // Assuming your AVL is in Domain
 import ucr.proyectoalgoritmos.Domain.flight.FlightHistory;
